<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sand Box 3D - beta</title>
    
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script> 
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <style>
        /* --- GLOBAL SETUP --- */
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }

        /* --- UI PANELS --- */
        .ui-panel-base {
            position: absolute;
            width: 250px;
            background: rgba(30, 30, 30, 0.95);
            border-radius: 8px;
            padding: 10px 15px 15px 15px;
            color: #eee;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid #444;
            pointer-events: auto;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 20;
            transition: none;
        }

        #left-panel { top: 20px; left: 20px; }
        #right-panel { top: 20px; right: 20px; }

        /* --- MINIMIZED STATE --- */
        .ui-panel-base.minimized {
            width: 140px; 
            height: 35px; 
            overflow: hidden; 
            padding: 0 10px;
            display: flex;
            align-items: center;
        }
        .ui-panel-base.minimized .panel-content { display: none; }
        .ui-panel-base.minimized .panel-header {
            border-bottom: none; 
            margin-bottom: 0; 
            padding-bottom: 0;
            width: 100%;
        }
        .ui-panel-base.minimized h2 { font-size: 13px; }

        /* --- COMPONENTS --- */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        h2 { margin: 0; font-size: 18px; color: #4aa3df; }
        
        .section-label {
            font-size: 11px;
            font-weight: bold;
            color: #888;
            margin-top: 15px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .instruction {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        .control-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px; }

        .slider-group {
            background: #252525;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            margin-bottom: 10px;
        }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; color: #ddd; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; }
        input[type=color] { width: 100%; height: 30px; border: none; padding: 0; background: none; cursor: pointer; }

        /* --- BUTTONS --- */
        button {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            text-align: left;
            display: flex;
            align-items: center;
            font-size: 13px;
            width: 100%; 
        }
        button:hover { background: #444; border-color: #777; }
        button.active { background: #2a5c80; border-color: #4aa3df; font-weight: bold; }

        .btn-minimize {
            width: 24px; height: 24px; padding: 0;
            display: flex; justify-content: center; align-items: center;
            font-size: 18px; line-height: 1;
            background: transparent; border: 1px solid #555;
        }

        button#btn-enter-game { background: #27ae60; border-color: #2ecc71; justify-content: center; font-weight: bold; margin-bottom: 5px; }
        button#btn-upload { background: #333; border-color: #888; justify-content: center; font-weight: bold; margin-bottom: 10px; margin-top: 5px; }
        button#btn-upload:hover { background: #555; border-color: #aaa; }

        button#btn-clear { background: #6e2828; border-color: #a34a4a; justify-content: center; font-weight: bold; margin-top: 10px; }

        /* Button Colors */
        button#btn-none, button#btn-none-tools { border-left: 4px solid #aaa; }
        button#btn-push { border-left: 4px solid #2ecc71; }
        button#btn-eraser { border-left: 4px solid #ff5252; }
        button#btn-view { border-left: 4px solid #9b59b6; }
        button#btn-freeze { border-left: 4px solid #3498db; }
        button#btn-build { border-left: 4px solid #e91e63; }
        button#btn-freeze.thaw-mode { border-left-color: #e67e22; }
        button#btn-freeze.thaw-mode.active { background: #a04000; border-color: #e67e22; }

        /* Custom Model Button */
        button#btn-custom { border-left: 4px solid #f39c12; }

        /* Explosives */
        button.btn-explosive { border-left: 4px solid #e74c3c; }
        button.btn-explosive.active { background: #802a2a; border-color: #df4a4a; }
        button#btn-frag { border-left: 4px solid #d35400; }

        /* --- ICONS --- */
        .shape-icon { width: 12px; height: 12px; margin-right: 10px; background: #ccc; display: inline-block; }
        .icon-box { border-radius: 2px; }
        .icon-sphere { border-radius: 50%; }
        .icon-cyl { border-radius: 2px; height: 16px; width: 8px; }
        .icon-tri { 
            width: 0; height: 0; background: transparent; 
            border-left: 6px solid transparent; border-right: 6px solid transparent; 
            border-bottom: 12px solid #ccc; 
        }
        .icon-bomb { border-radius: 50%; background: #e74c3c; border: 1px solid #000; }
        .icon-frag { border-radius: 50%; background: #d35400; border: 2px dashed #000; }
        .icon-custom { background: #f39c12; border-radius: 3px; border: 1px solid #fff; }
        
        .icon-hand { background: transparent; border: 1px solid #2ecc71; width: 10px; height: 10px;}
        .icon-cam { background: transparent; border: 2px solid #f1c40f; width: 12px; height: 8px; border-radius: 2px; }
        .icon-eye { background: transparent; border: 2px solid #9b59b6; border-radius: 50%; width: 12px; height: 6px; margin-top: 3px; position: relative; }
        .icon-eye::after { content:''; position: absolute; left: 3px; top: 0; width: 4px; height: 4px; background: #9b59b6; border-radius: 50%; }
        .icon-ice { background: #3498db; transform: rotate(45deg); width: 8px; height: 8px; }
        .icon-glue { background: #e91e63; width: 10px; height: 4px; border-radius: 1px; }
        .icon-eraser { background: white; transform: rotate(45deg); width: 10px; height: 6px; border: 1px solid #aaa; }
        .icon-x { background: transparent; color: #aaa; font-weight: bold; font-size: 14px; line-height: 10px; width: auto; height: auto; }
        .icon-play { background: transparent; border-left: 10px solid white; border-top: 6px solid transparent; border-bottom: 6px solid transparent; width: 0; height: 0; margin-right: 5px; }
        .icon-upload { background: transparent; width: 12px; height: 12px; border-bottom: 2px solid #ccc; position: relative; }
        .icon-upload::after { content:''; position: absolute; left: 3px; top: -2px; width: 0; height: 0; border-left: 3px solid transparent; border-right: 3px solid transparent; border-bottom: 6px solid #ccc; }

        /* --- MOBILE CONTROLS --- */
        .mobile-pad {
            position: absolute; bottom: 30px; width: 120px; height: 120px; z-index: 10;
            display: grid; 
            pointer-events: none;
            grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 5px;
        }
        #move-controls { left: 30px; }
        #look-controls { right: 30px; }
        .d-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; color: white; font-size: 18px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; pointer-events: auto; user-select: none; touch-action: manipulation;
        }
        .d-btn:active { background: rgba(74, 163, 223, 0.5); border-color: #4aa3df; }
        .btn-u { grid-column: 2; grid-row: 1; }
        .btn-l { grid-column: 1; grid-row: 2; }
        .btn-r { grid-column: 3; grid-row: 2; }
        .btn-d { grid-column: 2; grid-row: 3; }
        .pad-label { grid-column: 2; grid-row: 2; display: flex; justify-content: center; align-items: center; font-size: 10px; color: #888; text-transform: uppercase; }

    </style>
</head>
<body>

    <input type="file" id="file-input" accept=".glb,.gltf,.obj" style="display: none;" onchange="handleFileUpload(this)">

    <div id="left-panel" class="ui-panel-base minimized">
        <div class="panel-header">
            <h2>Tools</h2>
            <button class="btn-minimize" id="btn-min-left" onclick="toggleLeftUI()" title="Toggle Menu">+</button>
        </div>

        <div class="panel-content">
            <button id="btn-enter-game" onclick="enterGame()">
                <span class="shape-icon icon-play"></span> FULLSCREEN
            </button>

            <button id="btn-upload" onclick="triggerUpload()">
                <span class="shape-icon icon-upload"></span> Upload 3D Model
            </button>
            
            <div class="instruction">
                <span id="txt-instruct">WASD to Fly<br>Arrows to Look<br>Left Click: Use Tool<br>Right Drag: Look</span>
            </div>

            <div class="section-label">Actions</div>
            <div class="control-group">
                <button id="btn-none-tools" onclick="selectShape('none')">
                    <span class="shape-icon icon-x">X</span> None (Safe Mode)
                </button>

                <button id="btn-view" onclick="toggleViewMode()">
                    <span class="shape-icon icon-eye"></span> Possess Object
                </button>
                <button id="btn-push" onclick="selectShape('push')">
                    <span class="shape-icon icon-hand"></span> Force Push
                </button>
                <button id="btn-eraser" onclick="selectShape('eraser')">
                    <span class="shape-icon icon-eraser"></span> Eraser
                </button>
                <button id="btn-freeze" onclick="toggleFreezeLogic()">
                    <span class="shape-icon icon-ice"></span> Freeze
                </button>
                <button id="btn-build" onclick="toggleBuildMode()">
                    <span class="shape-icon icon-glue"></span> Build Mode
                </button>
            </div>
            
            <button id="btn-clear" onclick="clearObjects()">CLEAR ALL</button>
        </div>
    </div>

    <div id="right-panel" class="ui-panel-base minimized">
        <div class="panel-header">
            <h2>Objects</h2>
            <button class="btn-minimize" id="btn-min-right" onclick="toggleRightUI()" title="Toggle Menu">+</button>
        </div>

        <div class="panel-content">
            
            <div class="section-label">Selection</div>
            <div class="control-group">
                 <button id="btn-none" onclick="selectShape('none')">
                    <span class="shape-icon icon-x">X</span> None (Safe Mode)
                </button>
            </div>

            <div class="section-label">Properties</div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Size</span>
                    <span id="size-display">1.0</span>
                </div>
                <input type="range" id="size-slider" min="0.2" max="5.0" step="0.1" value="1.0" oninput="updateSize(this.value)">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>Color</span></div>
                <input type="color" id="color-picker" value="#3498db">
            </div>

            <div id="custom-model-container" style="display: none;">
                <div class="section-label">Custom</div>
                <div class="control-group">
                    <button id="btn-custom" onclick="selectShape('custom')">
                        <span class="shape-icon icon-custom"></span> <span id="custom-name">Spawn Upload</span>
                    </button>
                </div>
            </div>

            <div class="section-label">Shapes</div>
            <div class="control-group">
                <button id="btn-box" class="active" onclick="selectShape('box')">
                    <span class="shape-icon icon-box"></span> Cube
                </button>
                <button id="btn-sphere" onclick="selectShape('sphere')">
                    <span class="shape-icon icon-sphere"></span> Sphere
                </button>
                <button id="btn-cyl" onclick="selectShape('cylinder')">
                    <span class="shape-icon icon-cyl"></span> Cylinder
                </button>
                <button id="btn-tri" onclick="selectShape('triangle')">
                    <span class="shape-icon icon-tri"></span> Triangle
                </button>
            </div>

            <div class="section-label">Explosives</div>
            <div class="control-group">
                <button id="btn-bomb" class="btn-explosive" onclick="selectShape('bomb')">
                    <span class="shape-icon icon-bomb"></span> Bomb
                </button>
                <button id="btn-frag" class="btn-explosive" onclick="selectShape('frag_bomb')">
                    <span class="shape-icon icon-frag"></span> Cluster Bomb
                </button>
            </div>

        </div>
    </div>

    <div id="move-controls" class="mobile-pad">
        <div class="d-btn btn-u" id="btn-move-up">▲</div>
        <div class="d-btn btn-l" id="btn-move-left">◀</div>
        <div class="pad-label">Move</div>
        <div class="d-btn btn-r" id="btn-move-right">▶</div>
        <div class="d-btn btn-d" id="btn-move-down">▼</div>
    </div>

    <div id="look-controls" class="mobile-pad">
        <div class="d-btn btn-u" id="btn-look-up">▲</div>
        <div class="d-btn btn-l" id="btn-look-left">◀</div>
        <div class="pad-label">Look</div>
        <div class="d-btn btn-r" id="btn-look-right">▶</div>
        <div class="d-btn btn-d" id="btn-look-down">▼</div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
        // ==========================================
        // SECTION 1: UI & INTERACTION LOGIC
        // ==========================================
        
        let selectedShape = 'box'; 
        let freezeAction = 'freeze'; 
        let isBuildMode = false; 
        let currentSize = 1.0; 
        let spawnedMeshes = [];    
        let sceneRef = null;
        let viewTargetMesh = null; 
        
        // Storage for the Custom Model "Prefab"
        let customModelTemplate = null; 

        const moveState = { up: false, down: false, left: false, right: false };
        const lookState = { up: false, down: false, left: false, right: false };

        // --- KEYBOARD CONTROLS ---
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(k === 'w') moveState.up = true;
            if(k === 's') moveState.down = true;
            if(k === 'a') moveState.left = true;
            if(k === 'd') moveState.right = true;
            if(e.key === "ArrowUp") lookState.up = true;
            if(e.key === "ArrowDown") lookState.down = true;
            if(e.key === "ArrowLeft") lookState.left = true;
            if(e.key === "ArrowRight") lookState.right = true;
        });

        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(k === 'w') moveState.up = false;
            if(k === 's') moveState.down = false;
            if(k === 'a') moveState.left = false;
            if(k === 'd') moveState.right = false;
            if(e.key === "ArrowUp") lookState.up = false;
            if(e.key === "ArrowDown") lookState.down = false;
            if(e.key === "ArrowLeft") lookState.left = false;
            if(e.key === "ArrowRight") lookState.right = false;
        });

        function enterGame() {
            const de = document.documentElement;
            if (de.requestFullscreen) de.requestFullscreen();
            else if (de.webkitRequestFullscreen) de.webkitRequestFullscreen();
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {});
            }
        }

        function triggerUpload() {
            document.getElementById('file-input').click();
        }

        function handleFileUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const blobUrl = URL.createObjectURL(file);
                const ext = file.name.split('.').pop().toLowerCase();
                
                if(sceneRef) {
                    // Update Button Text
                    document.getElementById('custom-name').innerText = file.name.length > 15 ? file.name.substring(0,12) + "..." : file.name;

                    BABYLON.SceneLoader.ImportMesh("", "", blobUrl, sceneRef, 
                        function (meshes, particleSystems, skeletons) {
                            if(meshes.length === 0) return;

                            // Calculate Bounds of the entire hierarchy
                            let min = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                            let max = new BABYLON.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

                            meshes.forEach(m => {
                                m.setParent(null); 
                                const b = m.getHierarchyBoundingVectors();
                                min = BABYLON.Vector3.Minimize(min, b.min);
                                max = BABYLON.Vector3.Maximize(max, b.max);
                            });

                            const width = max.x - min.x;
                            const height = max.y - min.y;
                            const depth = max.z - min.z;
                            const center = min.add(max).scale(0.5);

                            // Create PREFAB CONTAINER (Hitbox)
                            const hitBox = BABYLON.MeshBuilder.CreateBox("customHitbox", {width: width, height: height, depth: depth}, sceneRef);
                            hitBox.isVisible = false; 
                            
                            // Parent meshes to hitbox and center them
                            meshes.forEach(m => {
                                m.parent = hitBox;
                                m.position = m.position.subtract(center);
                            });

                            // --- KEY CHANGE: Do NOT spawn into world yet. Store as Template. ---
                            hitBox.setEnabled(false); // Hide the prefab
                            
                            if (customModelTemplate && customModelTemplate.mesh) {
                                customModelTemplate.mesh.dispose(); // Cleanup old upload if exists
                            }

                            customModelTemplate = {
                                mesh: hitBox,
                                dimensions: { width, height, depth }
                            };

                            // Reveal the UI Button and Select it
                            document.getElementById('custom-model-container').style.display = 'block';
                            selectShape('custom');
                            
                            input.value = "";
                        }, 
                        null, 
                        function (scene, message, exception) {
                            console.error("Error loading file:", message);
                            alert("Failed to load model.");
                        },
                        "." + ext
                    );
                }
            }
        }

        function toggleLeftUI() {
            const left = document.getElementById('left-panel');
            const right = document.getElementById('right-panel');
            const leftBtn = document.getElementById('btn-min-left');
            const rightBtn = document.getElementById('btn-min-right');

            const isMinimizing = !left.classList.contains('minimized');
            
            if (isMinimizing) {
                left.classList.add('minimized');
                leftBtn.innerText = "+";
            } else {
                left.classList.remove('minimized');
                leftBtn.innerText = "-";
                right.classList.add('minimized');
                rightBtn.innerText = "+";
            }
        }

        function toggleRightUI() {
            const left = document.getElementById('left-panel');
            const right = document.getElementById('right-panel');
            const leftBtn = document.getElementById('btn-min-left');
            const rightBtn = document.getElementById('btn-min-right');

            const isMinimizing = !right.classList.contains('minimized');

            if (isMinimizing) {
                right.classList.add('minimized');
                rightBtn.innerText = "+";
            } else {
                right.classList.remove('minimized');
                rightBtn.innerText = "-";
                left.classList.add('minimized');
                leftBtn.innerText = "+";
            }
        }

        function toggleBuildMode() {
            if(selectedShape === 'none' || selectedShape === 'eraser' || selectedShape === 'push' || selectedShape === 'view') {
                selectShape('box');
                isBuildMode = true; 
            } else {
                isBuildMode = !isBuildMode; 
            }

            const btn = document.getElementById('btn-build');
            if(isBuildMode) btn.classList.add('active');
            else btn.classList.remove('active');
        }

        function selectShape(shape) {
            selectedShape = shape;
            const instruct = document.getElementById('txt-instruct');
            
            document.querySelectorAll('button').forEach(b => {
                if(!b.classList.contains('btn-minimize') && b.id !== 'btn-enter-game' && b.id !== 'btn-build' && b.id !== 'btn-upload') {
                    b.classList.remove('active');
                }
            });

            if (shape === 'none') {
                isBuildMode = false;
                document.getElementById('btn-build').classList.remove('active');
            }

            if (shape === 'view') {
                workshop.shaman.sandbox3d.resetCameraTarget();
                instruct.innerHTML = "CLICK object to Possess.<br>Click 'Possess' again to Exit.";
            }
            else {
                viewTargetMesh = null;
                instruct.innerHTML = "WASD to Fly<br>Arrows to Look<br>Left Click: Use Tool<br>Right Drag: Look";
            }

            let btnId = 'btn-' + shape;
            if (shape === 'cylinder') btnId = 'btn-cyl';
            if (shape === 'triangle') btnId = 'btn-tri';
            if (shape === 'frag_bomb') btnId = 'btn-frag';
            
            const activeBtn = document.getElementById(btnId);
            if(activeBtn) activeBtn.classList.add('active');

            if (shape === 'none') {
                 const btnTools = document.getElementById('btn-none-tools');
                 if(btnTools) btnTools.classList.add('active');
                 const btnRight = document.getElementById('btn-none');
                 if(btnRight) btnRight.classList.add('active');
            }

            if(shape === 'freeze' && freezeAction === 'thaw') {
                document.getElementById('btn-freeze').classList.add('thaw-mode');
            }
        }

        function updateSize(val) {
            currentSize = parseFloat(val);
            document.getElementById('size-display').innerText = currentSize.toFixed(1);
        }

        function toggleFreezeLogic() {
            const btn = document.getElementById('btn-freeze');
            if(selectedShape === 'freeze') {
                if(freezeAction === 'freeze') {
                    freezeAction = 'thaw';
                    btn.innerHTML = '<span class="shape-icon icon-ice" style="background:#e67e22"></span> Unfreeze';
                    btn.classList.add('thaw-mode');
                } else {
                    freezeAction = 'freeze';
                    btn.innerHTML = '<span class="shape-icon icon-ice"></span> Freeze';
                    btn.classList.remove('thaw-mode');
                }
            } else {
                selectShape('freeze');
            }
        }

        function toggleViewMode() {
            if(selectedShape === 'view') {
                viewTargetMesh = null;
                selectShape('box'); 
            } else {
                selectShape('view');
            }
        }

        function clearObjects() {
            if (!sceneRef) return;
            if(selectedShape === 'view') toggleViewMode();
            viewTargetMesh = null;
            spawnedMeshes.forEach(mesh => { if(mesh && !mesh.isDisposed()) mesh.dispose(); });
            spawnedMeshes = [];
        }

        function setupMobileButtons() {
            const bindBtn = (id, targetState, key) => {
                const el = document.getElementById(id);
                if(!el) return;
                const set = (active) => { targetState[key] = active; };
                el.addEventListener('mousedown', (e) => { e.preventDefault(); set(true); });
                el.addEventListener('mouseup', (e) => { e.preventDefault(); set(false); });
                el.addEventListener('mouseleave', () => { set(false); });
                el.addEventListener('touchstart', (e) => { e.preventDefault(); set(true); }, {passive: false});
                el.addEventListener('touchend', (e) => { e.preventDefault(); set(false); });
            };
            bindBtn('btn-move-up', moveState, 'up');
            bindBtn('btn-move-down', moveState, 'down');
            bindBtn('btn-move-left', moveState, 'left');
            bindBtn('btn-move-right', moveState, 'right');
            bindBtn('btn-look-up', lookState, 'up');
            bindBtn('btn-look-down', lookState, 'down');
            bindBtn('btn-look-left', lookState, 'left');
            bindBtn('btn-look-right', lookState, 'right');
        }
        setupMobileButtons();

        // ==========================================
        // SECTION 2: BABYLON 3D ENGINE
        // ==========================================

        const workshop = {
            shaman: {
                sandbox3d: {
                    canvas: document.getElementById("renderCanvas"),
                    engine: null,
                    scene: null,
                    cameraFree: null,

                    init: function() {
                        this.engine = new BABYLON.Engine(this.canvas, true);
                        this.scene = this.createScene();
                        sceneRef = this.scene;

                        this.engine.runRenderLoop(() => {
                            this.handleKillZone(); 
                            this.handleInput();    
                            this.scene.render();
                        });
                        window.addEventListener("resize", () => { this.engine.resize(); });
                    },

                    createScene: function() {
                        const scene = new BABYLON.Scene(this.engine);
                        // Standard gravity
                        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

                        this.cameraFree = new BABYLON.UniversalCamera("CameraFree", new BABYLON.Vector3(0, 20, -40), scene);
                        this.cameraFree.setTarget(BABYLON.Vector3.Zero());
                        this.cameraFree.fov = 1.2;
                         
                        this.cameraFree.keysUp = [];
                        this.cameraFree.keysDown = [];
                        this.cameraFree.keysLeft = [];
                        this.cameraFree.keysRight = [];
                        
                        this.cameraFree.attachControl(this.canvas, true);
                        
                        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                        light.intensity = 0.8;
                        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
                        dirLight.intensity = 0.5;

                        const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 200, height: 200}, scene);
                        const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
                        groundMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.2);
                        groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                        ground.material = groundMat;
                        ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.5, friction: 0.5 }, scene);

                        const ramp = BABYLON.MeshBuilder.CreateBox("ramp", {width: 15, height: 1, depth: 30}, scene);
                        ramp.position = new BABYLON.Vector3(30, 4, 0); 
                        ramp.rotation.z = Math.PI / 8;
                        const rampMat = new BABYLON.StandardMaterial("rampMat", scene);
                        rampMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.3);
                        ramp.material = rampMat;
                        ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.2, friction: 0.4 }, scene);

                        this.createPillars(scene);
                        this.setupInteraction(scene);
                        return scene;
                    },

                    resetCameraTarget: function() { },

                    handleKillZone: function() {
                        const killY = -100;
                        for(let i = spawnedMeshes.length - 1; i >= 0; i--) {
                            const mesh = spawnedMeshes[i];
                            if(mesh && !mesh.isDisposed()) {
                                if(mesh.position.y < killY) {
                                    if(mesh === viewTargetMesh) toggleViewMode();
                                    mesh.dispose();
                                    spawnedMeshes.splice(i, 1);
                                }
                            }
                        }
                    },

                    handleInput: function() {
                        if(!this.cameraFree) return;
                        
                        const cam = this.cameraFree;
                        const lookSpeed = 0.02;
                        const moveSpeed = 0.5;

                        if(lookState.left) cam.rotation.y -= lookSpeed;
                        if(lookState.right) cam.rotation.y += lookSpeed;
                        if(lookState.up) cam.rotation.x -= lookSpeed;
                        if(lookState.down) cam.rotation.x += lookSpeed;

                        if (selectedShape === 'view' && viewTargetMesh && viewTargetMesh.physicsImpostor) {
                            cam.position.copyFrom(viewTargetMesh.position);
                            cam.position.y += (3.0 * (currentSize || 1)); 

                            const forcePower = 0.5 * (viewTargetMesh.physicsImpostor.mass); 
                            const impulse = BABYLON.Vector3.Zero();
                            const forward = cam.getDirection(BABYLON.Vector3.Forward());
                            const right = cam.getDirection(BABYLON.Vector3.Right());
                            forward.y = 0; forward.normalize();
                            right.y = 0; right.normalize();

                            if(moveState.up) impulse.addInPlace(forward.scale(forcePower));
                            if(moveState.down) impulse.addInPlace(forward.scale(-forcePower));
                            if(moveState.left) impulse.addInPlace(right.scale(-forcePower));
                            if(moveState.right) impulse.addInPlace(right.scale(forcePower));

                            if(!impulse.equals(BABYLON.Vector3.Zero())) {
                                viewTargetMesh.physicsImpostor.applyImpulse(impulse, viewTargetMesh.getAbsolutePosition());
                            }
                        } else {
                            if(moveState.up) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Forward()).scale(moveSpeed));
                            if(moveState.down) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Backward()).scale(moveSpeed));
                            if(moveState.left) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Left()).scale(moveSpeed));
                            if(moveState.right) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Right()).scale(moveSpeed));
                        }
                    },

                    createPillars: function(scene) {
                        const mat = new BABYLON.StandardMaterial("pillarMat", scene);
                        mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);

                        for(let i=0; i < 15; i++) {
                            const height = 10 + Math.random() * 15;
                            const size = 2 + Math.random() * 3;
                            const pillar = BABYLON.MeshBuilder.CreateBox("pillar" + i, {height: height, width: size, depth: size}, scene);
                            let x = (Math.random() - 0.5) * 160;
                            let z = (Math.random() - 0.5) * 160;
                            if(Math.abs(x) < 20 && Math.abs(z) < 20) { x += 40; }
                            pillar.position = new BABYLON.Vector3(x, height/2, z);
                            pillar.material = mat;
                            pillar.physicsImpostor = new BABYLON.PhysicsImpostor(pillar, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);
                        }
                    },

                    setupInteraction: function(scene) {
                        let isDragging = false;
                        let lastPointerX = 0;
                        let lastPointerY = 0;

                        scene.onPointerObservable.add((pointerInfo) => {
                            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                                if (pointerInfo.event.button === 2) { 
                                    isDragging = true;
                                    lastPointerX = pointerInfo.event.clientX;
                                    lastPointerY = pointerInfo.event.clientY;
                                }
                            }
                            else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERUP) {
                                if (pointerInfo.event.button === 2) isDragging = false;
                            }
                            else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE && isDragging) {
                                const dx = pointerInfo.event.clientX - lastPointerX;
                                const dy = pointerInfo.event.clientY - lastPointerY;
                                lastPointerX = pointerInfo.event.clientX;
                                lastPointerY = pointerInfo.event.clientY;
                                
                                if(this.cameraFree) {
                                    this.cameraFree.rotation.y += dx * 0.002;
                                    this.cameraFree.rotation.x += dy * 0.002;
                                }
                            }

                            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                                if(pointerInfo.event.button !== 0) return; 
                                if(selectedShape === 'none') return; 

                                const pickInfo = pointerInfo.pickInfo;
                                if (pickInfo.hit && pickInfo.pickedMesh) {
                                    // Handle Interaction with loaded models (hitbox)
                                    let mesh = pickInfo.pickedMesh;

                                    // FIX: Check for both the template name AND spawned instance names
                                    if(mesh.parent && (mesh.parent.name.includes("customHitbox") || mesh.parent.name.includes("customInstance"))) {
                                        mesh = mesh.parent;
                                    }


                                    if (selectedShape === 'view') {
                                        if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                            viewTargetMesh = mesh;
                                            document.getElementById('txt-instruct').innerHTML = "Controlling Object.<br>WASD to Move. Click 'Possess' again to Exit.";
                                        }
                                        return;
                                    }

                                    if (selectedShape === 'eraser') {
                                        if (mesh.name === "ground" || mesh.name === "ramp") return; 
                                        mesh.dispose();
                                        const index = spawnedMeshes.indexOf(mesh);
                                        if (index > -1) spawnedMeshes.splice(index, 1);
                                        return;
                                    }

                                    if (selectedShape === 'freeze') {
                                        if (!mesh.physicsImpostor || mesh.name === "ground" || mesh.name === "ramp") return;
                                        if (freezeAction === 'freeze') {
                                            if(!mesh.metadata) mesh.metadata = {};
                                            if(mesh.physicsImpostor.mass > 0) {
                                                mesh.metadata.originalMass = mesh.physicsImpostor.mass;
                                                mesh.physicsImpostor.setMass(0);
                                                mesh.physicsImpostor.sleep();
                                                if(mesh.material) {
                                                    mesh.metadata.originalColor = mesh.material.diffuseColor ? mesh.material.diffuseColor.clone() : null;
                                                    if(mesh.material.emissiveColor) mesh.material.emissiveColor = new BABYLON.Color3(0.2, 0.6, 1);
                                                }
                                            }
                                        } else {
                                            if(mesh.metadata && mesh.metadata.originalMass) {
                                                mesh.physicsImpostor.setMass(mesh.metadata.originalMass);
                                                mesh.physicsImpostor.wakeUp();
                                                if(mesh.material && mesh.metadata.originalColor) {
                                                    if(mesh.material.diffuseColor) mesh.material.diffuseColor = mesh.metadata.originalColor;
                                                    if(mesh.material.emissiveColor) mesh.material.emissiveColor = new BABYLON.Color3(0,0,0);
                                                }
                                                mesh.metadata = null;
                                            }
                                        }
                                        return;
                                    }
                                    
                                    if (selectedShape === 'push') {
                                        if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                            const ray = pickInfo.ray;
                                            const forceDirection = ray.direction;
                                            const forceMagnitude = 50 * (mesh.scaling.x); 
                                            mesh.physicsImpostor.applyImpulse(forceDirection.scale(forceMagnitude), pickInfo.pickedPoint);
                                        }
                                        return; 
                                    }
                                    
                                    this.spawnObject(selectedShape, pickInfo, scene);
                                }
                            }
                        });
                        
                        window.addEventListener("contextmenu", e => e.preventDefault());
                    },

                    spawnObject: function(type, pickInfo, scene) {
                        const normal = pickInfo.getNormal(true);
                        if(!normal) return;

                        let mesh;
                        const mat = new BABYLON.StandardMaterial("objMat" + Date.now(), scene);
                        
                        const pickerVal = document.getElementById('color-picker').value;
                        mat.diffuseColor = BABYLON.Color3.FromHexString(pickerVal);
                        
                        const scale = currentSize; 
                        const pivotOffset = scale * 0.5 + (isBuildMode ? 0 : 0.01);
                        const spawnPos = pickInfo.pickedPoint.add(normal.scale(pivotOffset));

                        if (type === 'custom' && customModelTemplate) {
                            // Clone the Template
                            mesh = customModelTemplate.mesh.clone("customInstance_" + Date.now());
                            mesh.setEnabled(true);
                            // Set scale based on user input relative to original size? 
                            // For now, let's keep original scale but allow the size slider to scale it further
                            mesh.scaling = new BABYLON.Vector3(scale, scale, scale);
                            // Adjust Spawn Position (hitbox pivot is center)
                            const customOffset = (customModelTemplate.dimensions.height * scale) / 2;
                            mesh.position = pickInfo.pickedPoint.add(normal.scale(customOffset));
                        }
                        else if (type === 'box') {
                            mesh = BABYLON.MeshBuilder.CreateBox("box", {size: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                        } 
                        else if (type === 'sphere') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'cylinder') {
                            mesh = BABYLON.MeshBuilder.CreateCylinder("cyl", {height: scale, diameter: scale/2}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'triangle') {
                            mesh = BABYLON.MeshBuilder.CreateCylinder("tri", {height: scale, diameter: scale, tessellation: 3}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'bomb' || type === 'frag_bomb') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("bomb", {diameter: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                            mat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1); 
                            mat.emissiveColor = new BABYLON.Color3(0.1, 0, 0); 
                            if (type === 'frag_bomb') mat.emissiveColor = new BABYLON.Color3(0.3, 0.1, 0); 
                        }

                        if (mesh) {
                            if(type !== 'custom') mesh.material = mat; // Don't override material for custom models
                            
                            let massVal = scale * 1.5;
                            
                            if (type === 'custom' && customModelTemplate) {
                                // Add Physics to the CLONED custom object
                                const d = customModelTemplate.dimensions;
                                // Box Impostor relies on scaling. If we scaled the mesh, the impostor scales too.
                                // We use the original dimensions from the template for the impostor config
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 5 * scale, restitution: 0.1, friction: 0.5 }, scene);
                            }
                            else if (type === 'box') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: massVal, restitution: 0.1, friction: 0.8 }, scene);
                            } else if (type === 'sphere' || type.includes('bomb')) {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass: massVal, restitution: 0.4, friction: 0.5 }, scene);
                            } else if (type === 'cylinder' || type === 'triangle') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: massVal, restitution: 0.1, friction: 0.8 }, scene);
                            }

                            if (type.includes('bomb')) this.armBomb(mesh, scene, type === 'frag_bomb');
                            
                            // JOINING LOGIC
                            if(isBuildMode && pickInfo.pickedMesh && pickInfo.pickedMesh.physicsImpostor && !type.includes('bomb')) {
                                const joint = new BABYLON.PhysicsJoint(BABYLON.PhysicsJoint.LockJoint, {});
                                pickInfo.pickedMesh.physicsImpostor.addJoint(mesh.physicsImpostor, joint);
                                if(mesh.material) mesh.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                            }
                            spawnedMeshes.push(mesh);
                        }
                    },

                    armBomb: function(bombMesh, scene, isFragment) {
                        let flashCount = 0;
                        const flashInterval = setInterval(() => {
                            if(!bombMesh || bombMesh.isDisposed()) { clearInterval(flashInterval); return; }
                            const colorOn = isFragment ? new BABYLON.Color3(1, 0.5, 0) : new BABYLON.Color3(1, 0, 0);
                            if (flashCount % 2 === 0) bombMesh.material.emissiveColor = colorOn;
                            else bombMesh.material.emissiveColor = new BABYLON.Color3(0.1, 0, 0);
                            flashCount++;
                        }, 500);

                        setTimeout(() => {
                            clearInterval(flashInterval);
                            if(bombMesh && !bombMesh.isDisposed()) {
                                this.explode(bombMesh.position, scene, isFragment, bombMesh.scaling.x);
                                bombMesh.dispose();
                            }
                        }, 4000);
                    },

                    explode: function(center, scene, isFragment, scaleMultiplier) {
                        const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", {diameter: 1 * scaleMultiplier}, scene);
                        explosion.position = center;
                        const expMat = new BABYLON.StandardMaterial("expMat", scene);
                        expMat.diffuseColor = isFragment ? new BABYLON.Color3(1, 0.8, 0) : new BABYLON.Color3(1, 0.5, 0);
                        expMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0);
                        expMat.alpha = 0.8;
                        explosion.material = expMat;

                        let scale = 1;
                        const anim = scene.onBeforeRenderObservable.add(() => {
                            scale += 0.8;
                            explosion.scaling = new BABYLON.Vector3(scale, scale, scale);
                            expMat.alpha -= 0.05;
                            if (expMat.alpha <= 0) {
                                scene.onBeforeRenderObservable.remove(anim);
                                explosion.dispose();
                            }
                        });

                        const blastRadius = 25 * scaleMultiplier;
                        const blastForce = 60 * scaleMultiplier; 
                        spawnedMeshes.forEach(mesh => {
                            if (mesh && !mesh.isDisposed() && mesh.physicsImpostor) {
                                if (mesh.metadata && mesh.metadata.originalMass) return;
                                const dir = mesh.getAbsolutePosition().subtract(center);
                                const dist = dir.length();
                                if (dist < blastRadius) {
                                    dir.normalize();
                                    const forceMagnitude = blastForce * (1 - dist / blastRadius);
                                    const contactPoint = mesh.getAbsolutePosition();
                                    const impulse = dir.scale(forceMagnitude);
                                    mesh.physicsImpostor.applyImpulse(impulse, contactPoint);
                                }
                            }
                        });

                        if (isFragment) this.spawnFragments(center, scene);
                    },

                    spawnFragments: function(center, scene) {
                        const numFrags = 20;
                        for(let i=0; i<numFrags; i++) {
                            const frag = BABYLON.MeshBuilder.CreateBox("frag", {size: 0.5}, scene);
                            frag.position = center.clone();
                            frag.position.y += 1;
                            frag.position.x += (Math.random() - 0.5);
                            frag.position.z += (Math.random() - 0.5);
                            const fMat = new BABYLON.StandardMaterial("fMat", scene);
                            fMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                            fMat.emissiveColor = new BABYLON.Color3(0.8, 0.3, 0); 
                            frag.material = fMat;
                            frag.physicsImpostor = new BABYLON.PhysicsImpostor(frag, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0.5, restitution: 0.1 }, scene);
                            const exDir = new BABYLON.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5).normalize();
                            frag.physicsImpostor.applyImpulse(exDir.scale(12), frag.getAbsolutePosition());
                            spawnedMeshes.push(frag);
                        }
                    }
                }
            }
        };

        workshop.shaman.sandbox3d.init();

    </script>
</body>
</html>