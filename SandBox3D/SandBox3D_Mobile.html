<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sand Box 3D for Mobile</title>
    
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script> 
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <style>
        /* --- GLOBAL SETUP --- */
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- UI PANELS --- */
        .ui-panel-base {
            position: absolute;
            width: 250px;
            background: rgba(30, 30, 30, 0.95);
            border-radius: 8px;
            padding: 10px 15px 15px 15px;
            color: #eee;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid #444;
            pointer-events: auto;
            max-height: 60vh; /* Reduced height for mobile screens */
            overflow-y: auto;
            z-index: 20;
            transition: none;
        }

        #left-panel { top: 10px; left: 10px; }
        #right-panel { top: 10px; right: 10px; }

        /* --- MINIMIZED STATE --- */
        .ui-panel-base.minimized {
            width: 40px; 
            height: 40px; 
            overflow: hidden; 
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%; /* Circle button for mobile minimization */
        }
        .ui-panel-base.minimized .panel-content { display: none; }
        .ui-panel-base.minimized .panel-header {
            border: none; margin: 0; padding: 0; width: 100%; height: 100%;
            justify-content: center;
        }
        .ui-panel-base.minimized h2 { display: none; }
        .ui-panel-base.minimized .btn-minimize { border: none; font-size: 24px; width: 100%; height: 100%; }

        /* --- COMPONENTS --- */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        h2 { margin: 0; font-size: 18px; color: #4aa3df; }
        
        .section-label {
            font-size: 11px;
            font-weight: bold;
            color: #888;
            margin-top: 15px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .instruction {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.4;
            background: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 4px;
        }
        .control-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px; }

        .slider-group {
            background: #252525;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            margin-bottom: 10px;
        }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; color: #ddd; margin-bottom: 5px; }
        input[type=range] { width: 100%; }
        input[type=color] { width: 100%; height: 30px; border: none; padding: 0; background: none; }

        /* --- BUTTONS --- */
        button {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 10px 12px; /* Larger touch targets */
            border-radius: 4px;
            text-align: left;
            display: flex;
            align-items: center;
            font-size: 13px;
            width: 100%; 
        }
        button.active { background: #2a5c80; border-color: #4aa3df; font-weight: bold; }

        .btn-minimize {
            width: 30px; height: 30px; padding: 0;
            display: flex; justify-content: center; align-items: center;
            font-size: 18px; line-height: 1;
            background: transparent; border: 1px solid #555;
        }

        /* --- FLASHBANG OVERLAY --- */
        #flash-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 9999; /* Above everything */
            pointer-events: none; /* Let clicks pass through */
            opacity: 0;
            /* Changed from Flex to Block so the image can stretch freely */
            display: block; 
        }
        
        #flash-meme-vid {
            /* FORCE FULL SCREEN */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            
            /* 'fill' stretches the image to hit every corner (might distort). 
               Change to 'cover' if you want to keep aspect ratio but crop edges. */
            object-fit: fill; 
            
            display: none; /* Hidden during the "White" flash phase */
        }

        /* Flashbang Button Color */
        button#btn-flashbang { border-left: 4px solid #f1c40f; }
        button#btn-flashbang.active { background: #635a2d; border-color: #f1c40f; }
        
        /* Icon for Flashbang */
        .icon-flash { 
            background: #f1c40f; 
            width: 8px; height: 14px; 
            border-radius: 2px; 
            border: 1px solid #fff;
        }

        .icon-throw { 
            background: transparent; 
            width: 10px; height: 10px; 
            border-top: 2px solid #fff; 
            border-right: 2px solid #fff; 
            border-radius: 0 5px 0 0; 
            transform: rotate(-15deg);
        }
        
        .action-btn-overlay {
            position: absolute;
            bottom: 170px; /* Just above the 130px Look Pad */
            right: 45px;   /* Aligned with the pad */
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(243, 156, 18, 0.3); /* Transparent Orange */
            border: 2px solid #f39c12;
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 15;
            touch-action: manipulation;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        .action-btn-overlay:active {
            background: rgba(243, 156, 18, 0.8);
            transform: scale(0.95);
        }

        .icon-structure {
            background: transparent;
            width: 10px; height: 10px;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 0 #ccc;
        }

        button#btn-enter-game { background: #27ae60; border-color: #2ecc71; justify-content: center; font-weight: bold; margin-bottom: 5px; }
        
        /* Upload Button */
        button#btn-upload { background: #333; border-color: #888; justify-content: center; font-weight: bold; margin-bottom: 10px; margin-top: 5px; }
        button#btn-upload:hover { background: #555; border-color: #aaa; }

        button#btn-clear { background: #6e2828; border-color: #a34a4a; justify-content: center; font-weight: bold; margin-top: 10px; }

        /* Button Colors */
        button#btn-none, button#btn-none-tools { border-left: 4px solid #aaa; }
        button#btn-push { border-left: 4px solid #2ecc71; }
        button#btn-eraser { border-left: 4px solid #ff5252; }
        button#btn-view { border-left: 4px solid #9b59b6; }
        button#btn-freeze { border-left: 4px solid #3498db; }
        button#btn-build { border-left: 4px solid #e91e63; }
        button#btn-freeze.thaw-mode { border-left-color: #e67e22; }
        button#btn-freeze.thaw-mode.active { background: #a04000; border-color: #e67e22; }
        button#btn-throw { border-left: 4px solid #f39c12; }
        button#btn-throw.active { background: #7e5109; border-color: #f39c12; }
        button#btn-structure { border-left: 4px solid #9b59b6; }
        button#btn-structure.active { background: #4a235a; border-color: #9b59b6; }

        /* Custom Model Button */
        button#btn-custom { border-left: 4px solid #f39c12; }

        /* Explosives */
        button.btn-explosive { border-left: 4px solid #e74c3c; }
        button.btn-explosive.active { background: #802a2a; border-color: #df4a4a; }
        button#btn-frag { border-left: 4px solid #d35400; }

        /* --- ICONS --- */
        .shape-icon { width: 12px; height: 12px; margin-right: 10px; background: #ccc; display: inline-block; }
        .icon-box { border-radius: 2px; }
        .icon-sphere { border-radius: 50%; }
        .icon-cyl { border-radius: 2px; height: 16px; width: 8px; }
        .icon-tri { 
            width: 0; height: 0; background: transparent; 
            border-left: 6px solid transparent; border-right: 6px solid transparent; 
            border-bottom: 12px solid #ccc; 
        }
        .icon-bomb { border-radius: 50%; background: #e74c3c; border: 1px solid #000; }
        .icon-frag { border-radius: 50%; background: #d35400; border: 2px dashed #000; }
        
        /* New Icons for Port */
        .icon-custom { background: #f39c12; border-radius: 3px; border: 1px solid #fff; }
        .icon-upload { background: transparent; width: 12px; height: 12px; border-bottom: 2px solid #ccc; position: relative; }
        .icon-upload::after { content:''; position: absolute; left: 3px; top: -2px; width: 0; height: 0; border-left: 3px solid transparent; border-right: 3px solid transparent; border-bottom: 6px solid #ccc; }
        
        .icon-hand { background: transparent; border: 1px solid #2ecc71; width: 10px; height: 10px;}
        .icon-cam { background: transparent; border: 2px solid #f1c40f; width: 12px; height: 8px; border-radius: 2px; }
        .icon-eye { background: transparent; border: 2px solid #9b59b6; border-radius: 50%; width: 12px; height: 6px; margin-top: 3px; position: relative; }
        .icon-eye::after { content:''; position: absolute; left: 3px; top: 0; width: 4px; height: 4px; background: #9b59b6; border-radius: 50%; }
        .icon-ice { background: #3498db; transform: rotate(45deg); width: 8px; height: 8px; }
        .icon-glue { background: #e91e63; width: 10px; height: 4px; border-radius: 1px; }
        .icon-eraser { background: white; transform: rotate(45deg); width: 10px; height: 6px; border: 1px solid #aaa; }
        .icon-x { background: transparent; color: #aaa; font-weight: bold; font-size: 14px; line-height: 10px; width: auto; height: auto; }
        .icon-play { background: transparent; border-left: 10px solid white; border-top: 6px solid transparent; border-bottom: 6px solid transparent; width: 0; height: 0; margin-right: 5px; }

        /* --- MOBILE CONTROLS --- */
        .mobile-pad {
            position: absolute; bottom: 20px; width: 130px; height: 130px; z-index: 10;
            display: grid; 
            pointer-events: none;
            grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 5px;
        }
        #move-controls { left: 20px; }
        #look-controls { right: 20px; }
        .d-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; color: white; font-size: 20px;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; user-select: none; touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .d-btn:active { background: rgba(74, 163, 223, 0.6); border-color: #4aa3df; }
        .btn-u { grid-column: 2; grid-row: 1; }
        .btn-l { grid-column: 1; grid-row: 2; }
        .btn-r { grid-column: 3; grid-row: 2; }
        .btn-d { grid-column: 2; grid-row: 3; }
        .pad-label { grid-column: 2; grid-row: 2; display: flex; justify-content: center; align-items: center; font-size: 10px; color: #bbb; text-transform: uppercase; font-weight: bold; text-shadow: 1px 1px 2px black;}

    </style>
</head>
<body>

    <input type="file" id="file-input" accept=".glb,.gltf,.obj" style="display: none;" onchange="handleFileUpload(this)">

    <div id="flash-layer">
        <video id="flash-meme-vid" playsinline preload="auto"
            style="width:100%; height:100%; object-fit:fill; display:none;">
            <source src="./asset/gahdayum.mp4" type="video/mp4">
        </video>
    </div>

    <audio id="explosion-snd" preload="auto">
        <source src="./asset/bomboclat.mp3" type="audio/mpeg">
    </audio>

    <div id="left-panel" class="ui-panel-base minimized">
        <div class="panel-header">
            <h2>Tools</h2>
            <button class="btn-minimize" id="btn-min-left" onclick="toggleLeftUI()">T</button>
        </div>

        <div class="panel-content">
            <button id="btn-enter-game" onclick="enterGame()">
                <span class="shape-icon icon-play"></span> FULLSCREEN
            </button>

            <button id="btn-graphics-toggle" onclick="toggleGraphicsUI()"
                style="border-left: 4px solid #4aa3df; margin-bottom: 10px;">
                <span class="shape-icon"
                    style="background: transparent; border: 2px solid #4aa3df; border-radius: 2px; width: 10px; height: 10px;"></span>
                Game Settings
            </button>
            
            <div id="graphics-sub-panel"
                style="display: none; background: rgba(20, 20, 20, 0.5); padding: 10px; border-radius: 4px; margin-bottom: 10px; border: 1px solid #444;">
                <div class="slider-group">
                    <div class="slider-label"><span>Resolution Scale</span><span id="val-res">100%</span></div>
                    <input type="range" id="opt-res" min="25" max="100" value="100" step="5" oninput="updateGameSettings()">
                </div>
            
                <div class="section-label">Performance</div>
                <div style="display: flex; width: 100%; gap: 4px; margin-bottom: 10px;">
                    <button class="fps-btn" onclick="setFPS(24)">24</button>
                    <button class="fps-btn" onclick="setFPS(30)">30</button>
                    <button class="fps-btn" onclick="setFPS(45)">45</button>
                    <button class="fps-btn" onclick="setFPS(60)">60</button>
                    <button class="fps-btn active" id="fps-unlimited" onclick="setFPS(0)">∞</button>
                </div>
            
                <div class="slider-group">
                    <div class="slider-label"><span>Render Distance</span><span id="val-view">500m</span></div>
                    <input type="range" id="opt-view" min="50" max="1500" value="500" step="50" oninput="updateGameSettings()">
                </div>
                <div class="slider-group">
                    <div class="slider-label"><span>FOV (Camera)</span><span id="val-fov">1.2</span></div>
                    <input type="range" id="opt-fov" min="0.5" max="2.5" value="1.2" step="0.1" oninput="updateGameSettings()">
                </div>
                <div class="section-label" style="margin-top: 10px;">Deep Optimization</div>
                <button id="btn-compat-mode" onclick="toggleCompatibilityMode()" style="border-left: 4px solid #f1c40f;">
                    Compatibility Mode: <span id="compat-status">OFF</span>
                </button>
                <div class="instruction" style="border-left-color: #f1c40f; margin-top:5px;">
                    Reduces resolution, physics precision to boost FPS, and improve overall performance. <b>Requires Restart.</b>
                </div>
            </div>

            <button id="btn-upload" onclick="triggerUpload()">
                <span class="shape-icon icon-upload"></span> Upload 3D Model
            </button>
            
            <div class="instruction">
                <span id="txt-instruct">Use D-Pads to Move & Look.<br>Tap screen to use Tool.</span>
            </div>

            <div class="section-label">Actions</div>
            <div class="control-group">
                <button id="btn-none-tools" onclick="selectShape('none')">
                    <span class="shape-icon icon-x">X</span> None (Safe Mode)
                </button>

                <button id="btn-view" onclick="toggleViewMode()">
                    <span class="shape-icon icon-eye"></span> Possess Object
                </button>
                <button id="btn-throw" onclick="selectShape('throw')">
                    <span class="shape-icon icon-throw"></span> Throw Object
                </button>
                <div id="throw-settings" class="slider-group" style="display: none; margin-top: 5px; border-left: 3px solid #f39c12;">
                    <div class="slider-label">
                        <span>Throw Power</span>
                        <span id="throw-display">50</span>
                    </div>
                    <input type="range" id="throw-slider" min="10" max="200" step="5" value="50" oninput="updateThrowForce(this.value)">
                </div>
                <button id="btn-push" onclick="selectShape('push')">
                    <span class="shape-icon icon-hand"></span> Force Push
                </button>
                <button id="btn-eraser" onclick="selectShape('eraser')">
                    <span class="shape-icon icon-eraser"></span> Eraser
                </button>
                <button id="btn-freeze" onclick="toggleFreezeLogic()">
                    <span class="shape-icon icon-ice"></span> Freeze
                </button>
                <button id="btn-build" onclick="toggleBuildMode()">
                    <span class="shape-icon icon-glue"></span> Build Mode
                </button>
            </div>
            
            <button id="btn-clear" onclick="clearObjects()">CLEAR ALL</button>
        </div>
    </div>

    <div id="right-panel" class="ui-panel-base minimized">
        <div class="panel-header">
            <h2>Objects</h2>
            <button class="btn-minimize" id="btn-min-right" onclick="toggleRightUI()">O</button>
        </div>

        <div class="panel-content">
            
            <div class="section-label">Selection</div>
            <div class="control-group">
                 <button id="btn-none" onclick="selectShape('none')">
                    <span class="shape-icon icon-x">X</span> None (Safe Mode)
                </button>
            </div>

            <div class="section-label">Properties</div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Size</span>
                    <span id="size-display">1.0</span>
                </div>
                <input type="range" id="size-slider" min="0.2" max="5.0" step="0.1" value="1.0" oninput="updateSize(this.value)">
            </div>
            
            <div class="slider-group">
                <div class="slider-label">
                    <span>Mass</span>
                    <span id="mass-display">1.5</span>
                </div>
                <input type="range" id="mass-slider" min="0.1" max="100.0" step="0.1" value="1.5" oninput="updateMass(this.value)">
            </div>
            <div id="structure-settings" class="slider-group" style="display: none; border-left: 3px solid #9b59b6;">
                <div class="slider-label"><span>Grid Size (L x H x W)</span></div>
                <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                    <input type="number" id="struct-x" value="5" min="1" max="20"
                        style="width: 30%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px;">
                    <input type="number" id="struct-y" value="5" min="1" max="20"
                        style="width: 30%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px;">
                    <input type="number" id="struct-z" value="1" min="1" max="20"
                        style="width: 30%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px;">
                </div>
            
                <div class="slider-label"><span>Block Type</span></div>
                <select id="struct-shape"
                    style="width: 100%; background: #333; color: white; border: 1px solid #555; padding: 5px; border-radius: 4px;">
                    <option value="box">Cube</option>
                    <option value="sphere">Sphere</option>
                    <option value="cylinder">Cylinder</option>
                    <option value="triangle">Triangle</option>
                </select>
            </div>

            <div class="slider-group">
                <div class="slider-label"><span>Color</span></div>
                <input type="color" id="color-picker" value="#3498db">
            </div>

            <div id="custom-model-container" style="display: none;">
                <div class="section-label">Custom</div>
                <div class="control-group">
                    <button id="btn-custom" onclick="selectShape('custom')">
                        <span class="shape-icon icon-custom"></span> <span id="custom-name">Spawn Upload</span>
                    </button>
                </div>
            </div>

            <div class="section-label">Shapes</div>
            <div class="control-group">
                <button id="btn-box" class="active" onclick="selectShape('box')">
                    <span class="shape-icon icon-box"></span> Cube
                </button>
                <button id="btn-sphere" onclick="selectShape('sphere')">
                    <span class="shape-icon icon-sphere"></span> Sphere
                </button>
                <button id="btn-cyl" onclick="selectShape('cylinder')">
                    <span class="shape-icon icon-cyl"></span> Cylinder
                </button>
                <button id="btn-tri" onclick="selectShape('triangle')">
                    <span class="shape-icon icon-tri"></span> Triangle
                </button>
                <button id="btn-structure" onclick="selectShape('structure')">
                    <span class="shape-icon icon-structure"></span> Structure
                </button>
            </div>

            <div class="section-label">Explosives</div>
            <div class="control-group">
                <button id="btn-bomb" class="btn-explosive" onclick="selectShape('bomb')">
                    <span class="shape-icon icon-bomb"></span> Bomb
                </button>
                <button id="btn-frag" class="btn-explosive" onclick="selectShape('frag_bomb')">
                    <span class="shape-icon icon-frag"></span> Cluster Bomb
                </button>
                <button id="btn-flashbang" onclick="selectShape('flashbang')">
                    <span class="shape-icon icon-flash"></span> Flashbang
                </button>
            </div>

        </div>
    </div>

    <div id="move-controls" class="mobile-pad">
        <div class="d-btn btn-u" id="btn-move-up">▲</div>
        <div class="d-btn btn-l" id="btn-move-left">◀</div>
        <div class="pad-label">Move</div>
        <div class="d-btn btn-r" id="btn-move-right">▶</div>
        <div class="d-btn btn-d" id="btn-move-down">▼</div>
    </div>

    <div id="look-controls" class="mobile-pad">
        <div class="d-btn btn-u" id="btn-look-up">▲</div>
        <div class="d-btn btn-l" id="btn-look-left">◀</div>
        <div class="pad-label">Look</div>
        <div class="d-btn btn-r" id="btn-look-right">▶</div>
        <div class="d-btn btn-d" id="btn-look-down">▼</div>
    </div>

    <button id="btn-action-throw" class="action-btn-overlay" onclick="triggerThrow()" style="display: none;">THROW</button>
    <canvas id="renderCanvas"></canvas>

    <script>
        // ==========================================
        // SECTION 1: UI & INTERACTION LOGIC
        // ==========================================
        
        let selectedShape = 'box'; 
        let freezeAction = 'freeze'; 
        let isBuildMode = false; 
        let currentSize = 1.0; 
        let currentMass = 1.5;
        let spawnedMeshes = [];    
        let sceneRef = null;
        let viewTargetMesh = null; 
        let throwForce = 50;
        const isCompatibilityMode = localStorage.getItem("sb3d_compat") === "true";

        let customModelTemplate = null;

        const moveState = { up: false, down: false, left: false, right: false };
        const lookState = { up: false, down: false, left: false, right: false };

        function enterGame() {
            const de = document.documentElement;
            if (de.requestFullscreen) de.requestFullscreen();
            else if (de.webkitRequestFullscreen) de.webkitRequestFullscreen();
            // Attempt to lock orientation to landscape
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {});
            }
        }

        setTimeout(() => {
            const statusSpan = document.getElementById("compat-status");
            const btn = document.getElementById("btn-compat-mode");
            if (statusSpan) {
                statusSpan.innerText = isCompatibilityMode ? "ON" : "OFF";
                if (isCompatibilityMode) {
                    btn.style.background = "#635a2d";
                    btn.classList.add('active');
                }
            }
        }, 100);

        function toggleCompatibilityMode() {
            // Confirm before reloading because they will lose their build
            if (confirm("Game must restart to apply deep optimizations. Current progress will be lost. Continue?")) {
                localStorage.setItem("sb3d_compat", !isCompatibilityMode);
                location.reload();
            }
        }

        // --- NEW FILE UPLOAD FUNCTIONS ---
        function triggerUpload() {
            document.getElementById('file-input').click();
        }

        function handleFileUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const blobUrl = URL.createObjectURL(file);
                const ext = file.name.split('.').pop().toLowerCase();
                
                if(sceneRef) {
                    document.getElementById('custom-name').innerText = file.name.length > 15 ? file.name.substring(0,12) + "..." : file.name;

                    BABYLON.SceneLoader.ImportMesh("", "", blobUrl, sceneRef, 
                        function (meshes, particleSystems, skeletons) {
                            if(meshes.length === 0) return;

                            let min = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                            let max = new BABYLON.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

                            meshes.forEach(m => {
                                m.setParent(null); 
                                const b = m.getHierarchyBoundingVectors();
                                min = BABYLON.Vector3.Minimize(min, b.min);
                                max = BABYLON.Vector3.Maximize(max, b.max);
                            });

                            const width = max.x - min.x;
                            const height = max.y - min.y;
                            const depth = max.z - min.z;
                            const center = min.add(max).scale(0.5);

                            const hitBox = BABYLON.MeshBuilder.CreateBox("customHitbox", {width: width, height: height, depth: depth}, sceneRef);
                            hitBox.isVisible = false; 
                            
                            meshes.forEach(m => {
                                m.parent = hitBox;
                                m.position = m.position.subtract(center);
                            });

                            hitBox.setEnabled(false);
                            
                            if (customModelTemplate && customModelTemplate.mesh) {
                                customModelTemplate.mesh.dispose();
                            }

                            customModelTemplate = {
                                mesh: hitBox,
                                dimensions: { width, height, depth }
                            };

                            document.getElementById('custom-model-container').style.display = 'block';
                            selectShape('custom');
                            
                            // Auto open objects panel logic for mobile if hidden?
                            const right = document.getElementById('right-panel');
                            if(right.classList.contains('minimized')) toggleRightUI();

                            input.value = "";
                        }, 
                        null, 
                        function (scene, message, exception) {
                            console.error("Error loading file:", message);
                            alert("Failed to load model.");
                        },
                        "." + ext
                    );
                }
            }
        }

        function updateThrowForce(val) {
                throwForce = parseFloat(val);
                document.getElementById('throw-display').innerText = throwForce;
            }

            function triggerThrow() {
                // This function is called by the big overlay button
                const sb3d = workshop.shaman.sandbox3d;
                if (!sb3d.scene || !sb3d.cameraFree) return;

                const cam = sb3d.cameraFree;
                const forward = cam.getDirection(BABYLON.Vector3.Forward());

                // 1. Create Projectile
                const projectile = BABYLON.MeshBuilder.CreateSphere("projectile", { diameter: 0.5 }, sb3d.scene);
                // Spawn 1.5 units in front of camera (center)
                projectile.position = cam.position.add(forward.scale(1.5));

                // 2. Material
                const pMat = new BABYLON.StandardMaterial("pMat", sb3d.scene);
                pMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 1.0);
                projectile.material = pMat;

                // 3. Physics
                projectile.physicsImpostor = new BABYLON.PhysicsImpostor(
                    projectile,
                    BABYLON.PhysicsImpostor.SphereImpostor,
                    { mass: 1, restitution: 0.5, friction: 0.5 },
                    sb3d.scene
                );

                // 4. Force
                projectile.physicsImpostor.applyImpulse(
                    forward.scale(throwForce),
                    projectile.getAbsolutePosition()
                );

                spawnedMeshes.push(projectile);
            }

        function toggleLeftUI() {
            const left = document.getElementById('left-panel');
            const right = document.getElementById('right-panel');
            const leftBtn = document.getElementById('btn-min-left');
            const rightBtn = document.getElementById('btn-min-right');

            const isMinimizing = !left.classList.contains('minimized');
            
            if (isMinimizing) {
                left.classList.add('minimized');
                leftBtn.innerText = "T";
            } else {
                left.classList.remove('minimized');
                leftBtn.innerText = "-";
                // Auto minimize other panel
                right.classList.add('minimized');
                rightBtn.innerText = "O";
            }
        }

        function toggleGraphicsUI() {
                const subPanel = document.getElementById('graphics-sub-panel');
                const btn = document.getElementById('btn-graphics-toggle');
                const isHidden = subPanel.style.display === 'none';

                subPanel.style.display = isHidden ? 'block' : 'none';
                btn.classList.toggle('active', isHidden);
            }

            function updateGameSettings() {
                // 1. Get Values from UI
                const resScale = document.getElementById('opt-res').value;
                const viewDist = document.getElementById('opt-view').value;
                const fovVal = document.getElementById('opt-fov').value;

                // 2. Update UI Labels
                document.getElementById('val-res').innerText = resScale + "%";
                document.getElementById('val-view').innerText = viewDist + "m";
                document.getElementById('val-fov').innerText = fovVal;

                // 3. Apply to Engine (Shaman Logic)
                const sb3d = workshop.shaman.sandbox3d;
                if (sb3d.engine && sb3d.cameraFree) {
                    sb3d.engine.setHardwareScalingLevel(1 / (resScale / 100));
                    sb3d.cameraFree.maxZ = parseFloat(viewDist);
                    sb3d.cameraFree.fov = parseFloat(fovVal);
                }
            }

        function toggleRightUI() {
            const left = document.getElementById('left-panel');
            const right = document.getElementById('right-panel');
            const leftBtn = document.getElementById('btn-min-left');
            const rightBtn = document.getElementById('btn-min-right');

            const isMinimizing = !right.classList.contains('minimized');

            if (isMinimizing) {
                right.classList.add('minimized');
                rightBtn.innerText = "O";
            } else {
                right.classList.remove('minimized');
                rightBtn.innerText = "-";
                // Auto minimize other panel
                left.classList.add('minimized');
                leftBtn.innerText = "T";
            }
        }

        function toggleBuildMode() {
            if(selectedShape === 'none' || selectedShape === 'eraser' || selectedShape === 'push' || selectedShape === 'view') {
                selectShape('box');
                isBuildMode = true; 
            } else {
                isBuildMode = !isBuildMode; 
            }

            const btn = document.getElementById('btn-build');
            if(isBuildMode) btn.classList.add('active');
            else btn.classList.remove('active');
        }

        function selectShape(shape) {
            selectedShape = shape;
            
            const instruct = document.getElementById('txt-instruct');
            const throwSettings = document.getElementById('throw-settings');
            const throwBtn = document.getElementById('btn-action-throw');
            const structSettings = document.getElementById('structure-settings');
            
            document.querySelectorAll('button').forEach(b => {
                if(!b.classList.contains('btn-minimize') && b.id !== 'btn-enter-game' && b.id !== 'btn-build' && b.id !== 'btn-upload') {
                    b.classList.remove('active');
                }
            });

            if (shape === 'none') {
                isBuildMode = false;
                document.getElementById('btn-build').classList.remove('active');
            }

            if (shape === 'throw') {
                throwSettings.style.display = 'block';
                throwBtn.style.display = 'flex'; // Show the Big Button
            } else {
                throwSettings.style.display = 'none';
                throwBtn.style.display = 'none'; // Hide the Big Button
            }

            if (shape === 'structure') {
                structSettings.style.display = 'block';
                instruct.innerHTML = "<b>Click</b>: Spawn Structure<br>Adjust L/H/W in Objects Panel.";
            } else {
                structSettings.style.display = 'none';
            }

            if (shape === 'view') {
                workshop.shaman.sandbox3d.resetCameraTarget();
                instruct.innerHTML = "Tap object to Possess.<br>Tap 'Possess' again to Exit.";
            }
            else {
                viewTargetMesh = null;
                instruct.innerHTML = "Use D-Pads to Move & Look.<br>Tap screen to use Tool.";
            }

            let btnId = 'btn-' + shape;
            if (shape === 'cylinder') btnId = 'btn-cyl';
            if (shape === 'triangle') btnId = 'btn-tri';
            if (shape === 'frag_bomb') btnId = 'btn-frag';
            if (shape === 'flashbang') btnId = 'btn-flashbang';
            
            const activeBtn = document.getElementById(btnId);
            if(activeBtn) activeBtn.classList.add('active');

            if (shape === 'none') {
                 const btnTools = document.getElementById('btn-none-tools');
                 if(btnTools) btnTools.classList.add('active');
                 const btnRight = document.getElementById('btn-none');
                 if(btnRight) btnRight.classList.add('active');
            }

            if(shape === 'freeze' && freezeAction === 'thaw') {
                document.getElementById('btn-freeze').classList.add('thaw-mode');
            }
        }

            let targetFPS = 60;
            let lastFrameTime = performance.now();

            function setFPS(val) {
                targetFPS = val;
                document.querySelectorAll('.fps-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if ((val === 0 && btn.innerText === '∞') || btn.innerText == val) btn.classList.add('active');
                });
            }


        function updateSize(val) {
            currentSize = parseFloat(val);
            document.getElementById('size-display').innerText = currentSize.toFixed(1);

            // AUTO-CALCULATE MASS based on Size (using your standard 1.5 multiplier)
            // This ensures big things get heavier automatically...
            currentMass = (currentSize * 1.5);

            // ...unless you manually change the mass slider afterwards.
            const massSlider = document.getElementById('mass-slider');
            const massDisplay = document.getElementById('mass-display');

            massSlider.value = currentMass;
            massDisplay.innerText = currentMass.toFixed(1);
        }

        function updateMass(val) {
            // Manual override for Mass
            currentMass = parseFloat(val);
            document.getElementById('mass-display').innerText = currentMass.toFixed(1);        
        }

        function toggleFreezeLogic() {
            const btn = document.getElementById('btn-freeze');
            if(selectedShape === 'freeze') {
                if(freezeAction === 'freeze') {
                    freezeAction = 'thaw';
                    btn.innerHTML = '<span class="shape-icon icon-ice" style="background:#e67e22"></span> Unfreeze';
                    btn.classList.add('thaw-mode');
                } else {
                    freezeAction = 'freeze';
                    btn.innerHTML = '<span class="shape-icon icon-ice"></span> Freeze';
                    btn.classList.remove('thaw-mode');
                }
            } else {
                selectShape('freeze');
            }
        }

        function toggleViewMode() {
            if(selectedShape === 'view') {
                viewTargetMesh = null;
                selectShape('box'); 
            } else {
                selectShape('view');
            }
        }

        function clearObjects() {
            if (!sceneRef) return;
            if(selectedShape === 'view') toggleViewMode();
            viewTargetMesh = null;
            spawnedMeshes.forEach(mesh => { if(mesh && !mesh.isDisposed()) mesh.dispose(); });
            spawnedMeshes = [];
        }

        function setupMobileButtons() {
            const bindBtn = (id, targetState, key) => {
                const el = document.getElementById(id);
                if(!el) return;
                const set = (active) => { targetState[key] = active; };
                
                // Touch events for mobile
                el.addEventListener('touchstart', (e) => { e.preventDefault(); set(true); }, {passive: false});
                el.addEventListener('touchend', (e) => { e.preventDefault(); set(false); });
                el.addEventListener('touchcancel', (e) => { e.preventDefault(); set(false); });
                
                // Keep Mouse events for testing in browser dev tools
                el.addEventListener('mousedown', (e) => { e.preventDefault(); set(true); });
                el.addEventListener('mouseup', (e) => { e.preventDefault(); set(false); });
                el.addEventListener('mouseleave', () => { set(false); });
            };
            bindBtn('btn-move-up', moveState, 'up');
            bindBtn('btn-move-down', moveState, 'down');
            bindBtn('btn-move-left', moveState, 'left');
            bindBtn('btn-move-right', moveState, 'right');
            bindBtn('btn-look-up', lookState, 'up');
            bindBtn('btn-look-down', lookState, 'down');
            bindBtn('btn-look-left', lookState, 'left');
            bindBtn('btn-look-right', lookState, 'right');
        }
        setupMobileButtons();

        // ==========================================
        // SECTION 2: BABYLON 3D ENGINE
        // ==========================================

        const workshop = {
            shaman: {
                sandbox3d: {
                    canvas: document.getElementById("renderCanvas"),
                    engine: null,
                    scene: null,
                    cameraFree: null,
                    cullingFrameCount: 0,
                    cullingRate: 10,

                    init: function() {
                        this.engine = new BABYLON.Engine(this.canvas, true);
                        this.scene = this.createScene();
                        sceneRef = this.scene;

                        this.engine.runRenderLoop(() => {
                            const now = performance.now();

                            if (isCompatibilityMode) {
                                // 2.0 = Half Resolution (Hardware Scaling)
                                // This makes the game look "pixelated" but runs much faster on laptops
                                this.engine.setHardwareScalingLevel(2.0);
                                this.cullingRate = 30; // Check distance only every 30 frames
                            } else {
                                this.engine.setHardwareScalingLevel(1.0); // Native Resolution
                                this.cullingRate = 10;
                            }

                            this.cullingFrameCount++;
                            if (this.cullingFrameCount > this.cullingRate) {
                                this.cullingFrameCount = 0;
                                this.handleDistanceCulling();
                            }

                            // SHAMAN LOGIC: If Unlimited (0), skip the math and render full speed
                            if (targetFPS === 0) {
                                this.handleKillZone();
                                this.handleInput(); // Important for Mobile Joysticks
                                this.scene.render();
                                return;
                            }

                            // APPLY THROTTLE: Only render if enough time has passed
                            const delta = now - lastFrameTime;
                            const interval = 1000 / targetFPS;

                            if (delta >= interval) {
                                lastFrameTime = now - (delta % interval);
                                this.handleKillZone();
                                this.handleInput();
                                this.scene.render();
                            }
                        });
                        window.addEventListener("resize", () => { this.engine.resize(); });
                    },

                    createScene: function() {
                        const scene = new BABYLON.Scene(this.engine);
                        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

                        this.cameraFree = new BABYLON.UniversalCamera("CameraFree", new BABYLON.Vector3(0, 20, -40), scene);
                        this.cameraFree.setTarget(BABYLON.Vector3.Zero());
                        this.cameraFree.fov = 1.2;
                        
                        this.cameraFree.keysUp = [];
                        this.cameraFree.keysDown = [];
                        this.cameraFree.keysLeft = [];
                        this.cameraFree.keysRight = [];
                        
                        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                        light.intensity = 1.2;
                        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
                        dirLight.intensity = 0.8;

                        const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 500, height: 500}, scene);
                        const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
                        groundMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.2);
                        groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                        ground.material = groundMat;
                        ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.5, friction: 0.5 }, scene);

                        const ramp = BABYLON.MeshBuilder.CreateBox("ramp", {width: 15, height: 1, depth: 30}, scene);
                        ramp.position = new BABYLON.Vector3(30, 1, 0); 
                        ramp.rotation.z = Math.PI / 8;
                        const rampMat = new BABYLON.StandardMaterial("rampMat", scene);
                        rampMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.3);
                        ramp.material = rampMat;
                        ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.2, friction: 0.4 }, scene);

                        this.createPillars(scene);
                        this.setupInteraction(scene);
                        return scene;
                    },

                    resetCameraTarget: function() { },

                    handleKillZone: function() {
                        const killY = -100;
                        for(let i = spawnedMeshes.length - 1; i >= 0; i--) {
                            const mesh = spawnedMeshes[i];
                            if(mesh && !mesh.isDisposed()) {
                                if(mesh.position.y < killY) {
                                    if(mesh === viewTargetMesh) toggleViewMode();
                                    mesh.dispose();
                                    spawnedMeshes.splice(i, 1);
                                }
                            }
                        }
                    },

                    handleDistanceCulling: function () {
                        if (!this.cameraFree) return;

                        // 1. Get the current limit from the camera (set by your slider)
                        const camPos = this.cameraFree.position;
                        const viewLimit = this.cameraFree.maxZ;
                        const viewLimitSq = viewLimit * viewLimit; // Compare squared numbers (faster for CPU)

                        // 2. Iterate through all dynamic objects
                        for (let i = 0; i < spawnedMeshes.length; i++) {
                            const mesh = spawnedMeshes[i];
                            if (!mesh || mesh.isDisposed()) continue;

                            // 3. Calculate Distance
                            // We use lengthSquared() because Math.sqrt() is expensive
                            const distSq = mesh.position.subtract(camPos).lengthSquared();

                            if (distSq > viewLimitSq) {
                                // --- TOO FAR ---
                                if (mesh.isEnabled()) {
                                    mesh.setEnabled(false); // Stop Rendering
                                    if (mesh.physicsImpostor) mesh.physicsImpostor.sleep(); // Stop Physics
                                }
                            } else {
                                // --- CLOSE ENOUGH ---
                                if (!mesh.isEnabled()) {
                                    mesh.setEnabled(true); // Start Rendering
                                    if (mesh.physicsImpostor) mesh.physicsImpostor.wakeUp(); // Resume Physics
                                }
                            }
                        }
                    },

                    handleInput: function() {
                        if(!this.cameraFree) return;
                        
                        const cam = this.cameraFree;
                        const lookSpeed = 0.03;
                        const moveSpeed = 0.5;

                        // Camera Rotation (Right Pad)
                        if(lookState.left) cam.rotation.y -= lookSpeed;
                        if(lookState.right) cam.rotation.y += lookSpeed;
                        if(lookState.up) cam.rotation.x -= lookSpeed;
                        if(lookState.down) cam.rotation.x += lookSpeed;

                        // Possessed Object Movement
                        if (selectedShape === 'view' && viewTargetMesh && viewTargetMesh.physicsImpostor) {
                            cam.position.copyFrom(viewTargetMesh.position);
                            cam.position.y += (3.0 * (currentSize || 1)); 

                            const forcePower = 0.5 * (viewTargetMesh.physicsImpostor.mass); 
                            const impulse = BABYLON.Vector3.Zero();
                            const forward = cam.getDirection(BABYLON.Vector3.Forward());
                            const right = cam.getDirection(BABYLON.Vector3.Right());
                            forward.y = 0; forward.normalize();
                            right.y = 0; right.normalize();

                            if(moveState.up) impulse.addInPlace(forward.scale(forcePower));
                            if(moveState.down) impulse.addInPlace(forward.scale(-forcePower));
                            if(moveState.left) impulse.addInPlace(right.scale(-forcePower));
                            if(moveState.right) impulse.addInPlace(right.scale(forcePower));

                            if(!impulse.equals(BABYLON.Vector3.Zero())) {
                                viewTargetMesh.physicsImpostor.applyImpulse(impulse, viewTargetMesh.getAbsolutePosition());
                            }
                        } 
                        // Free Camera Movement (Left Pad)
                        else {
                            if(moveState.up) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Forward()).scale(moveSpeed));
                            if(moveState.down) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Backward()).scale(moveSpeed));
                            if(moveState.left) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Left()).scale(moveSpeed));
                            if(moveState.right) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Right()).scale(moveSpeed));
                        }
                    },

                    createPillars: function(scene) {
                        const mat = new BABYLON.StandardMaterial("pillarMat", scene);
                        mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);

                        for (let i = 0; i < 25; i++) {
                            const pillar = BABYLON.MeshBuilder.CreateBox("pillar", { width: 4, height: 15, depth: 4 }, scene);

                            // Distribution math for 500x500 map:
                            // (Math.random() * TotalSize) - (HalfSize)
                            let posX = Math.random() * 500 - 250;
                            let posZ = Math.random() * 500 - 250;

                            pillar.position = new BABYLON.Vector3(posX, 7.5, posZ);

                            const pMat = new BABYLON.StandardMaterial("pMat", scene);
                            pMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                            pillar.material = pMat;

                            pillar.physicsImpostor = new BABYLON.PhysicsImpostor(pillar, BABYLON.PhysicsImpostor.BoxImpostor, {
                                mass: 0,
                                restitution: 0.1,
                                friction: 0.5
                            }, scene);
                        }
                    },

                    setupInteraction: function(scene) {
                        scene.onPointerObservable.add((pointerInfo) => {
                            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                                // Touch or Left Click
                                if(pointerInfo.event.button !== 0 && pointerInfo.event.type !== 'touchstart') return; 
                                if(selectedShape === 'none') return; 

                                const pickInfo = pointerInfo.pickInfo;
                                if (pickInfo.hit && pickInfo.pickedMesh) {
                                    // Modified to handle custom hitbox parenting logic if needed
                                    let mesh = pickInfo.pickedMesh;
                                    if(mesh.parent && (mesh.parent.name.includes("customHitbox") || mesh.parent.name.includes("customInstance"))) {
                                        mesh = mesh.parent;
                                    }

                                    if (selectedShape === 'view') {
                                        if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                            viewTargetMesh = mesh;
                                            document.getElementById('txt-instruct').innerHTML = "Controlling Object.<br>Use D-Pads. Tap 'Possess' again to Exit.";
                                        }
                                        return;
                                    }

                                    if (selectedShape === 'eraser') {
                                        if (mesh.name === "ground" || mesh.name === "ramp") return; 
                                        mesh.dispose();
                                        const index = spawnedMeshes.indexOf(mesh);
                                        if (index > -1) spawnedMeshes.splice(index, 1);
                                        return;
                                    }

                                    if (selectedShape === 'freeze') {
                                        if (!mesh.physicsImpostor || mesh.name === "ground" || mesh.name === "ramp") return;
                                        if (freezeAction === 'freeze') {
                                            if(!mesh.metadata) mesh.metadata = {};
                                            if(mesh.physicsImpostor.mass > 0) {
                                                mesh.metadata.originalMass = mesh.physicsImpostor.mass;
                                                mesh.metadata.originalColor = mesh.material && mesh.material.diffuseColor ? mesh.material.diffuseColor.clone() : null;
                                                mesh.metadata.originalEmissive = mesh.material && mesh.material.emissiveColor ? mesh.material.emissiveColor.clone() : new BABYLON.Color3(0,0,0);
                                                mesh.physicsImpostor.setMass(0);
                                                mesh.physicsImpostor.sleep();
                                                if(mesh.material) {
                                                    mesh.material.emissiveColor = new BABYLON.Color3(0.2, 0.6, 1); 
                                                    mesh.material.diffuseColor = new BABYLON.Color3(0.5, 0.8, 1);
                                                    mesh.material.alpha = 0.8;
                                                }
                                            }
                                        } else {
                                            if(mesh.metadata && mesh.metadata.originalMass) {
                                                mesh.physicsImpostor.setMass(mesh.metadata.originalMass);
                                                mesh.physicsImpostor.wakeUp();
                                                if(mesh.material) {
                                                    mesh.material.emissiveColor = mesh.metadata.originalEmissive;
                                                    mesh.material.diffuseColor = mesh.metadata.originalColor;
                                                    mesh.material.alpha = 1.0;
                                                }
                                                mesh.metadata = null;
                                            }
                                        }
                                        return;
                                    }

                                    if (selectedShape === 'structure') {
                                        this.spawnStructure(pickInfo, scene);
                                        return;
                                    }
                                    
                                    if (selectedShape === 'push') {
                                        if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                            const ray = pickInfo.ray;
                                            const forceDirection = ray.direction;
                                            const forceMagnitude = 50 * (mesh.scaling.x); 
                                            mesh.physicsImpostor.applyImpulse(forceDirection.scale(forceMagnitude), pickInfo.pickedPoint);
                                        }
                                        return; 
                                    }
                                    
                                    this.spawnObject(selectedShape, pickInfo, scene);
                                }
                            }
                        });
                        
                        window.addEventListener("contextmenu", e => e.preventDefault());
                    },

                    spawnObject: function(type, pickInfo, scene) {
                        const normal = pickInfo.getNormal(true);
                        if(!normal) return;

                        let mesh;
                        const mat = new BABYLON.StandardMaterial("objMat" + Date.now(), scene);
                        
                        const pickerVal = document.getElementById('color-picker').value;
                        mat.diffuseColor = BABYLON.Color3.FromHexString(pickerVal);
                        
                        const scale = currentSize; 
                        const pivotOffset = scale * 0.5 + (isBuildMode ? 0 : 0.01);
                        const spawnPos = pickInfo.pickedPoint.add(normal.scale(pivotOffset));

                        // --- UPDATED SPAWN LOGIC TO INCLUDE CUSTOM MODELS ---
                        if (type === 'custom' && customModelTemplate) {
                            mesh = customModelTemplate.mesh.clone("customInstance_" + Date.now());
                            mesh.setEnabled(true);
                            mesh.scaling = new BABYLON.Vector3(scale, scale, scale);
                            const customOffset = (customModelTemplate.dimensions.height * scale) / 2;
                            mesh.position = pickInfo.pickedPoint.add(normal.scale(customOffset));
                        }
                        else if (type === 'box') {
                            mesh = BABYLON.MeshBuilder.CreateBox("box", {size: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                        } 
                        else if (type === 'sphere') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'cylinder') {
                            mesh = BABYLON.MeshBuilder.CreateCylinder("cyl", {height: scale, diameter: scale/2}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'triangle') {
                            mesh = BABYLON.MeshBuilder.CreateCylinder("tri", {height: scale, diameter: scale, tessellation: 3}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'bomb' || type === 'frag_bomb') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("bomb", {diameter: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                            mat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1); 
                            mat.emissiveColor = new BABYLON.Color3(0.1, 0, 0); 
                            if (type === 'frag_bomb') mat.emissiveColor = new BABYLON.Color3(0.3, 0.1, 0); 
                        }
                        // --- NEW FLASHBANG MESH ---
                        else if (type === 'flashbang') {
                            // Flashbangs look like canisters (Cylinders)
                            mesh = BABYLON.MeshBuilder.CreateCylinder("flashbang", { height: scale * 1.5, diameter: scale * 0.5 }, scene);
                            mesh.position.copyFrom(spawnPos);
                            // Flashbang color (Yellow/White tip)
                            mat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                            mat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0);
                        }

                        if (mesh) {
                            // Only apply color material to non-custom shapes
                            if(type !== 'custom') mesh.material = mat;
                            
                            const massVal = currentMass; 

                            if (type === 'custom' && customModelTemplate) {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 5 * scale, restitution: 0.1, friction: 0.5 }, scene);
                            }
                            else if (type === 'box') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: massVal, restitution: 0.1, friction: 0.8 }, scene);
                            } else if (type === 'sphere' || type.includes('bomb')) {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass: massVal, restitution: 0.4, friction: 0.5 }, scene);
                            } else if (type === 'cylinder' || type === 'triangle') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: massVal, restitution: 0.1, friction: 0.8 }, scene);
                            }
                            else if (type === 'flashbang') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: massVal, restitution: 0.3, friction: 0.5 }, scene);
                                this.armBomb(mesh, scene, false, true); // Pass 'true' for isFlash
                            }

                            if (type.includes('bomb')) this.armBomb(mesh, scene, type === 'frag_bomb');
                            
                            // JOINING LOGIC
                            if(isBuildMode && pickInfo.pickedMesh && pickInfo.pickedMesh.physicsImpostor && !type.includes('bomb')) {
                                const joint = new BABYLON.PhysicsJoint(BABYLON.PhysicsJoint.LockJoint, {});
                                pickInfo.pickedMesh.physicsImpostor.addJoint(mesh.physicsImpostor, joint);
                                if(mesh.material) mesh.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                            }
                            spawnedMeshes.push(mesh);
                        }
                    },

                    spawnStructure: function (pickInfo, scene) {
                        const normal = pickInfo.getNormal(true);
                        if (!normal) return;

                        // Get Dimensions from Input
                        // We clamp them to avoid crashing the browser with 10000 blocks
                        let dimX = parseInt(document.getElementById('struct-x').value) || 1;
                        let dimY = parseInt(document.getElementById('struct-y').value) || 1;
                        let dimZ = parseInt(document.getElementById('struct-z').value) || 1;

                        // Hard Cap for safety (Max 10x10x10)
                        if (dimX > 10) dimX = 10;
                        if (dimY > 10) dimY = 10;
                        if (dimZ > 10) dimZ = 10;

                        const shapeType = document.getElementById('struct-shape').value;
                        const scale = currentSize;

                        // Calculate Start Position (Offset so it builds UP and OUT from the click)
                        // We add a tiny gap (scale * 1.02) to prevent immediate physics explosion
                        const gap = scale * 1.02;
                        const startPos = pickInfo.pickedPoint.add(normal.scale(scale / 2));

                        for (let x = 0; x < dimX; x++) {
                            for (let y = 0; y < dimY; y++) {
                                for (let z = 0; z < dimZ; z++) {

                                    // Calculate Offset
                                    const offsetX = (x - dimX / 2) * gap; // Center X
                                    const offsetY = y * gap;            // Build Up Y
                                    const offsetZ = (z - dimZ / 2) * gap; // Center Z

                                    const spawnPos = startPos.add(new BABYLON.Vector3(offsetX, offsetY, offsetZ));

                                    // We reuse the logic from spawnObject, but we need to bypass the 'pickInfo' requirement.
                                    // So we simply create the mesh directly here to keep it fast.
                                    this.createSingleBlock(shapeType, spawnPos, scale, scene);
                                }
                            }
                        }
                    },

                    createSingleBlock: function (type, position, scale, scene) {
                        let mesh;
                        const mat = new BABYLON.StandardMaterial("structMat" + Date.now() + Math.random(), scene);
                        const pickerVal = document.getElementById('color-picker').value;
                        mat.diffuseColor = BABYLON.Color3.FromHexString(pickerVal);

                        if (type === 'box') mesh = BABYLON.MeshBuilder.CreateBox("s_box", { size: scale }, scene);
                        else if (type === 'sphere') mesh = BABYLON.MeshBuilder.CreateSphere("s_sphere", { diameter: scale }, scene);
                        else if (type === 'cylinder') mesh = BABYLON.MeshBuilder.CreateCylinder("s_cyl", { height: scale, diameter: scale / 2 }, scene);
                        else if (type === 'triangle') mesh = BABYLON.MeshBuilder.CreateCylinder("s_tri", { height: scale, diameter: scale, tessellation: 3 }, scene);

                        if (mesh) {
                            mesh.position = position;
                            mesh.material = mat;

                            // Physics
                            let impostorType = BABYLON.PhysicsImpostor.BoxImpostor;
                            if (type === 'sphere') impostorType = BABYLON.PhysicsImpostor.SphereImpostor;
                            if (type === 'cylinder' || type === 'triangle') impostorType = BABYLON.PhysicsImpostor.CylinderImpostor;

                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, impostorType, {
                                mass: currentMass,
                                restitution: 0.1,
                                friction: 0.8
                            }, scene);

                            spawnedMeshes.push(mesh);
                        }
                    },

                    armBomb: function (bombMesh, scene, isFragment, isFlash = false) {
                        let flashCount = 0;
                        const flashInterval = setInterval(() => {
                            if (!bombMesh || bombMesh.isDisposed()) { clearInterval(flashInterval); return; }

                            // Visual countdown colors
                            let colorOn = new BABYLON.Color3(1, 0, 0); // Default Red
                            if (isFragment) colorOn = new BABYLON.Color3(1, 0.5, 0); // Orange
                            if (isFlash) colorOn = new BABYLON.Color3(1, 1, 1); // White for Flashbang

                            if (flashCount % 2 === 0) bombMesh.material.emissiveColor = colorOn;
                            else bombMesh.material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                            flashCount++;
                        }, isFlash ? 200 : 500); // Flashbangs beep faster

                        setTimeout(() => {
                            clearInterval(flashInterval);
                            if (bombMesh && !bombMesh.isDisposed()) {
                                // Trigger explosion or flash
                                if (isFlash) this.triggerFlashbang(bombMesh.position, scene);
                                else this.explode(bombMesh.position, scene, isFragment, bombMesh.scaling.x);

                                bombMesh.dispose();
                            }
                        }, isFlash ? 2500 : 4000); // Flashbangs explode sooner (2.5s)
                    },

                    explode: function (center, scene, isFragment, scaleMultiplier, playSound = true) {
                        // Only play sound if playSound is true (default)
                        if (playSound) {
                            const snd = document.getElementById('explosion-snd');
                            if (snd) {
                                snd.currentTime = 0;
                                snd.volume = 1.0;
                                snd.play().catch(e => console.log("Audio blocked: Interaction required."));
                            }
                        }

                        const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", { diameter: 1 * scaleMultiplier }, scene);
                        explosion.position = center;
                        const expMat = new BABYLON.StandardMaterial("expMat", scene);
                        expMat.diffuseColor = isFragment ? new BABYLON.Color3(1, 0.8, 0) : new BABYLON.Color3(1, 0.5, 0);
                        expMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0);
                        expMat.alpha = 0.8;
                        explosion.material = expMat;

                        let scale = 1;
                        const anim = scene.onBeforeRenderObservable.add(() => {
                            scale += 0.8;
                            explosion.scaling = new BABYLON.Vector3(scale, scale, scale);
                            expMat.alpha -= 0.05;
                            if (expMat.alpha <= 0) {
                                scene.onBeforeRenderObservable.remove(anim);
                                explosion.dispose();
                            }
                        });

                        const blastRadius = 25 * scaleMultiplier;
                        const blastForce = 60 * scaleMultiplier;
                        spawnedMeshes.forEach(mesh => {
                            if (mesh && !mesh.isDisposed() && mesh.physicsImpostor) {
                                if (mesh.metadata && mesh.metadata.originalMass) return;
                                const dir = mesh.getAbsolutePosition().subtract(center);
                                const dist = dir.length();
                                if (dist < blastRadius) {
                                    dir.normalize();
                                    const forceMagnitude = blastForce * (1 - dist / blastRadius);
                                    const contactPoint = mesh.getAbsolutePosition();
                                    const impulse = dir.scale(forceMagnitude);
                                    mesh.physicsImpostor.applyImpulse(impulse, contactPoint);
                                }
                            }
                        });

                        if (isFragment) this.spawnFragments(center, scene);
                    },

                    triggerFlashbang: function (center, scene) {
                        // Keep the small physical explosion for physics impact, BUT SILENCE THE BOMBOCLAT (playSound = false)
                        this.explode(center, scene, false, 0.2, false);

                        const layer = document.getElementById('flash-layer');
                        const video = document.getElementById('flash-meme-vid');
                        if (!layer || !video) return;

                        // Reset layer and prepare video immediately
                        layer.style.transition = 'none';
                        layer.style.backgroundColor = 'transparent';
                        layer.style.opacity = '1';

                        video.currentTime = 0;
                        video.muted = false;
                        video.volume = 1.0;
                        video.style.display = 'block';

                        // Immediate Playback of Gahdayum
                        video.play().catch(e => {
                            console.error("Audio/Video blocked! Ensure pointer is locked or screen clicked.", e);
                        });

                        // Start fading out towards the end of the clip
                        setTimeout(() => {
                            layer.style.transition = 'opacity 1.5s ease-out';
                            layer.style.opacity = '0';
                        }, 3700);

                        // Complete cleanup
                        setTimeout(() => {
                            video.pause();
                            video.style.display = 'none';
                        }, 5250);
                    },

                    spawnFragments: function(center, scene) {
                        const numFrags = isCompatibilityMode ? 5 : 20;
                        for(let i=0; i<numFrags; i++) {
                            const frag = BABYLON.MeshBuilder.CreateBox("frag", {size: 0.5}, scene);
                            frag.position = center.clone();
                            frag.position.y += (Math.random() - 0.5) * 0.2;
                            frag.position.x += (Math.random() - 0.5) * 0.1;
                            frag.position.z += (Math.random() - 0.5) * 0.1;
                            const fMat = new BABYLON.StandardMaterial("fMat", scene);
                            fMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                            fMat.emissiveColor = new BABYLON.Color3(0.8, 0.3, 0); 
                            frag.material = fMat;
                            frag.physicsImpostor = new BABYLON.PhysicsImpostor(frag, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0.5, restitution: 0.1 }, scene);
                            const exDir = new BABYLON.Vector3(
                                Math.random() - 0.5,
                                Math.random() - 0.5, // Allow negative Y for a spherical blast
                                Math.random() - 0.5
                            ).normalize();
                            frag.physicsImpostor.applyImpulse(exDir.scale(12), frag.getAbsolutePosition());
                            spawnedMeshes.push(frag);
                        }
                    }
                }
            }
        };

        workshop.shaman.sandbox3d.init();

    </script>
</body>
</html>