<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sand Box 3D</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
        }
        
        /* UI OVERLAY */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            background: rgba(30, 30, 30, 0.95);
            border-radius: 8px;
            padding: 10px 15px 15px 15px;
            color: #eee;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid #444;
            user-select: none;
            pointer-events: auto; 
            transition: height 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 20;
        }

        /* --- MOBILE CONTROLS --- */
        .mobile-pad {
            position: absolute;
            bottom: 30px;
            width: 120px;
            height: 120px;
            z-index: 10;
            display: none;
            pointer-events: none;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 5px;
        }
        
        .mobile-pad.visible { display: grid; }

        #move-controls { left: 30px; }
        #look-controls { right: 30px; }

        .d-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            user-select: none;
            touch-action: manipulation;
        }
        .d-btn:active { background: rgba(74, 163, 223, 0.5); border-color: #4aa3df; }
        
        #look-controls .d-btn { border-color: rgba(241, 196, 15, 0.5); }
        #look-controls .d-btn:active { background: rgba(241, 196, 15, 0.3); }

        .btn-u { grid-column: 2; grid-row: 1; }
        .btn-l { grid-column: 1; grid-row: 2; }
        .btn-r { grid-column: 3; grid-row: 2; }
        .btn-d { grid-column: 2; grid-row: 3; }
        .pad-label { 
            grid-column: 2; grid-row: 2; 
            display: flex; justify-content: center; align-items: center;
            font-size: 10px; color: #888; text-transform: uppercase;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        h2 { margin: 0; font-size: 18px; color: #4aa3df; }

        #btn-minimize {
            background: transparent;
            border: 1px solid #555;
            color: #aaa;
            width: 24px;
            height: 24px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            line-height: 1;
        }
        #btn-minimize:hover { background: #444; color: white; }

        #ui-panel.minimized .panel-content { display: none; }
        #ui-panel.minimized { width: 200px; }
        #ui-panel.minimized .panel-header { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }

        .section-label {
            font-size: 11px;
            font-weight: bold;
            color: #888;
            margin-top: 15px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .instruction {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 10px;
        }

        button {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            align-items: center;
            font-size: 13px;
        }
        
        button:hover { background: #444; border-color: #777; }
        button.active { background: #2a5c80; border-color: #4aa3df; font-weight: bold; }

        /* TOOLS COLORS */
        button#btn-none { border-left: 4px solid #aaa; }
        button#btn-none.active { background: #555; border-color: #999; }
        
        button#btn-push { border-left: 4px solid #2ecc71; }
        button#btn-push.active { background: #27ae60; border-color: #2ecc71; }

        button#btn-freecam { border-left: 4px solid #f1c40f; }
        button#btn-freecam.active { background: #b7950b; border-color: #f1c40f; }

        /* VIEW MODE COLOR */
        button#btn-view { border-left: 4px solid #9b59b6; }
        button#btn-view.active { background: #6c3483; border-color: #8e44ad; }

        /* FREEZE BUTTON */
        button#btn-freeze { border-left: 4px solid #3498db; }
        button#btn-freeze.active { background: #2980b9; border-color: #3498db; }
        button#btn-freeze.thaw-mode { border-left-color: #e67e22; }
        button#btn-freeze.thaw-mode.active { background: #a04000; border-color: #e67e22; }

        /* BOMB BUTTON STYLE */
        button.btn-explosive { border-left: 4px solid #e74c3c; }
        button.btn-explosive.active { background: #802a2a; border-color: #df4a4a; }
        button.btn-explosive:hover { background: #5c2828; }

        button#btn-frag { border-left: 4px solid #d35400; }

        button#btn-clear {
            background: #6e2828;
            border-color: #a34a4a;
            justify-content: center;
            font-weight: bold;
            margin-top: 10px;
            width: 100%;
        }
        button#btn-clear:hover { background: #8f3434; }

        /* SHAPE ICONS */
        .shape-icon { width: 12px; height: 12px; margin-right: 10px; background: #ccc; display: inline-block; }
        .icon-box { border-radius: 2px; }
        .icon-sphere { border-radius: 50%; }
        .icon-cyl { border-radius: 2px; height: 16px; width: 8px; }
        .icon-bomb { border-radius: 50%; background: #e74c3c; border: 1px solid #000; }
        .icon-frag { border-radius: 50%; background: #d35400; border: 2px dashed #000; }
        .icon-hand { background: transparent; border: 1px solid #2ecc71; width: 10px; height: 10px;}
        .icon-cam { background: transparent; border: 2px solid #f1c40f; width: 12px; height: 8px; border-radius: 2px; }
        .icon-eye { background: transparent; border: 2px solid #9b59b6; border-radius: 50%; width: 12px; height: 6px; margin-top: 3px; position: relative; }
        .icon-eye::after { content:''; position: absolute; left: 3px; top: 0; width: 4px; height: 4px; background: #9b59b6; border-radius: 50%; }
        .icon-ice { background: #3498db; transform: rotate(45deg); width: 8px; height: 8px; }
        .icon-x { background: transparent; color: #aaa; font-weight: bold; font-size: 14px; line-height: 10px; width: auto; height: auto; }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script> 
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>

    <div id="ui-panel">
        <div class="panel-header">
            <h2>Physics Panel</h2>
            <button id="btn-minimize" onclick="toggleUI()" title="Toggle Menu">-</button>
        </div>

        <div class="panel-content">
            <div class="instruction">
                <span id="txt-instruct">Left Click: Use Tool<br>Right Drag: Rotate Camera</span>
            </div>

            <div class="section-label">Tools</div>
            <div class="control-group">
                <button id="btn-none" onclick="selectShape('none')">
                    <span class="shape-icon icon-x">X</span> None Mode
                </button>
                <button id="btn-freecam" onclick="selectShape('freecam')">
                    <span class="shape-icon icon-cam"></span> FreeCam Mode (Fly)
                </button>
                <button id="btn-view" onclick="toggleViewMode()">
                    <span class="shape-icon icon-eye"></span> Possess (Toggle)
                </button>
                <button id="btn-push" onclick="selectShape('push')">
                    <span class="shape-icon icon-hand"></span> Force Push
                </button>
                <button id="btn-freeze" onclick="toggleFreezeLogic()">
                    <span class="shape-icon icon-ice"></span> Freeze Object
                </button>
            </div>

            <div class="section-label">Shapes</div>
            <div class="control-group">
                <button id="btn-box" class="active" onclick="selectShape('box')">
                    <span class="shape-icon icon-box"></span> Cube
                </button>
                <button id="btn-sphere" onclick="selectShape('sphere')">
                    <span class="shape-icon icon-sphere"></span> Sphere
                </button>
                <button id="btn-cyl" onclick="selectShape('cylinder')">
                    <span class="shape-icon icon-cyl"></span> Cylinder
                </button>
            </div>

            <div class="section-label">Explosives</div>
            <div class="control-group">
                <button id="btn-bomb" class="btn-explosive" onclick="selectShape('bomb')">
                    <span class="shape-icon icon-bomb"></span> Normal Bomb
                </button>
                <button id="btn-frag" class="btn-explosive" onclick="selectShape('frag_bomb')">
                    <span class="shape-icon icon-frag"></span> Debris Bomb
                </button>
            </div>

            <button id="btn-clear" onclick="clearObjects()">CLEAR SCENE</button>
        </div>
    </div>

    <div id="move-controls" class="mobile-pad">
        <div class="d-btn btn-u" id="btn-move-up">▲</div>
        <div class="d-btn btn-l" id="btn-move-left">◀</div>
        <div class="pad-label">Move</div>
        <div class="d-btn btn-r" id="btn-move-right">▶</div>
        <div class="d-btn btn-d" id="btn-move-down">▼</div>
    </div>

    <div id="look-controls" class="mobile-pad">
        <div class="d-btn btn-u" id="btn-look-up">▲</div>
        <div class="d-btn btn-l" id="btn-look-left">◀</div>
        <div class="pad-label">Look</div>
        <div class="d-btn btn-r" id="btn-look-right">▶</div>
        <div class="d-btn btn-d" id="btn-look-down">▼</div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
        // --- SANDBOX LOGIC ---
        
        let selectedShape = 'box'; 
        let freezeAction = 'freeze'; 
        let spawnedMeshes = [];    
        let sceneRef = null;
        let viewTargetMesh = null; // Object currently being controlled

        // Control States
        const moveState = { up: false, down: false, left: false, right: false };
        const lookState = { up: false, down: false, left: false, right: false };

        // --- UI FUNCTIONS ---

        function toggleUI() {
            const panel = document.getElementById('ui-panel');
            const btn = document.getElementById('btn-minimize');
            panel.classList.toggle('minimized');
            btn.innerText = panel.classList.contains('minimized') ? "+" : "-";
        }

        function toggleFreezeLogic() {
            const btn = document.getElementById('btn-freeze');
            if(selectedShape === 'freeze') {
                if(freezeAction === 'freeze') {
                    freezeAction = 'thaw';
                    btn.innerHTML = '<span class="shape-icon icon-ice" style="background:#e67e22"></span> Unfreeze Object';
                    btn.classList.add('thaw-mode');
                } else {
                    freezeAction = 'freeze';
                    btn.innerHTML = '<span class="shape-icon icon-ice"></span> Freeze Object';
                    btn.classList.remove('thaw-mode');
                }
            } else {
                selectShape('freeze');
            }
        }

        // --- KEY FIX FOR VIEW MODE SNAP BACK ---
        function toggleViewMode() {
            if(selectedShape === 'view') {
                // EXITING View Mode
                viewTargetMesh = null;
                
                // FORCE RESET Camera Position to Center Platform
                const cam = workshop.shaman.sandbox3d.cameraFree;
                if(cam) {
                    cam.position.set(0, 20, -50);
                    cam.setTarget(BABYLON.Vector3.Zero());
                }

                selectShape('box'); // Switch back to default tool (calls switchCamera inside)
            } else {
                // ENTERING View Mode
                selectShape('view');
            }
        }

        function selectShape(shape) {
            selectedShape = shape;
            const instruct = document.getElementById('txt-instruct');
            const movePad = document.getElementById('move-controls');
            const lookPad = document.getElementById('look-controls');

            // Reset UI
            document.querySelectorAll('.control-group button').forEach(b => b.classList.remove('active'));
            
            // Handle Camera Swapping
            if(shape === 'freecam') {
                viewTargetMesh = null; // Reset view target
                workshop.shaman.sandbox3d.switchCamera(true);
                instruct.innerHTML = "WASD / Arrows to Fly";
                movePad.classList.add('visible');
                lookPad.classList.add('visible');
            } 
            else if (shape === 'view') {
                // Initial state for View Mode (before clicking object)
                workshop.shaman.sandbox3d.switchCamera(true); // Use free cam logic but will override position
                instruct.innerHTML = "CLICK an object to Control it.<br>Click 'View Mode' button to Exit.";
                movePad.classList.add('visible');
                lookPad.classList.add('visible');
            }
            else {
                viewTargetMesh = null;
                workshop.shaman.sandbox3d.switchCamera(false); // Orbit cam
                instruct.innerHTML = "Left Click: Use Tool<br>Right Drag: Rotate Camera";
                movePad.classList.remove('visible');
                lookPad.classList.remove('visible');
            }

            // Highlight Buttons
            if(shape === 'box') document.getElementById('btn-box').classList.add('active');
            if(shape === 'sphere') document.getElementById('btn-sphere').classList.add('active');
            if(shape === 'cylinder') document.getElementById('btn-cyl').classList.add('active');
            if(shape === 'bomb') document.getElementById('btn-bomb').classList.add('active');
            if(shape === 'frag_bomb') document.getElementById('btn-frag').classList.add('active');
            if(shape === 'push') document.getElementById('btn-push').classList.add('active');
            if(shape === 'none') document.getElementById('btn-none').classList.add('active');
            if(shape === 'freecam') document.getElementById('btn-freecam').classList.add('active');
            if(shape === 'view') document.getElementById('btn-view').classList.add('active');
            
            if(shape === 'freeze') {
                const btn = document.getElementById('btn-freeze');
                btn.classList.add('active');
                if(freezeAction === 'thaw') btn.classList.add('thaw-mode');
            }
        }

        function clearObjects() {
            if (!sceneRef) return;
            
            // If clearing while viewing, reset first
            if(selectedShape === 'view') toggleViewMode();
            
            viewTargetMesh = null;
            spawnedMeshes.forEach(mesh => {
                if(mesh && !mesh.isDisposed()) {
                    mesh.dispose();
                }
            });
            spawnedMeshes = [];
        }

        // --- SETUP MOBILE BUTTONS ---
        function setupMobileButtons() {
            const bindBtn = (id, targetState, key) => {
                const el = document.getElementById(id);
                if(!el) return;
                // Mouse
                el.addEventListener('mousedown', (e) => { e.preventDefault(); targetState[key] = true; });
                el.addEventListener('mouseup', (e) => { e.preventDefault(); targetState[key] = false; });
                el.addEventListener('mouseleave', () => { targetState[key] = false; });
                // Touch
                el.addEventListener('touchstart', (e) => { e.preventDefault(); targetState[key] = true; }, {passive: false});
                el.addEventListener('touchend', (e) => { e.preventDefault(); targetState[key] = false; });
            };

            // Bind Movement
            bindBtn('btn-move-up', moveState, 'up');
            bindBtn('btn-move-down', moveState, 'down');
            bindBtn('btn-move-left', moveState, 'left');
            bindBtn('btn-move-right', moveState, 'right');

            // Bind Looking
            bindBtn('btn-look-up', lookState, 'up');
            bindBtn('btn-look-down', lookState, 'down');
            bindBtn('btn-look-left', lookState, 'left');
            bindBtn('btn-look-right', lookState, 'right');
        }
        setupMobileButtons();

        // --- BABYLON CONFIG ---

        const workshop = {
            shaman: {
                sandbox3d: {
                    canvas: document.getElementById("renderCanvas"),
                    engine: null,
                    scene: null,
                    
                    cameraOrbit: null,
                    cameraFree: null,

                    init: function() {
                        this.engine = new BABYLON.Engine(this.canvas, true);
                        this.scene = this.createScene();
                        sceneRef = this.scene;

                        this.engine.runRenderLoop(() => {
                            this.handleKillZone(); // Check for falling objects
                            this.handleInput();    // Handle View Mode & FreeCam
                            this.scene.render();
                        });

                        window.addEventListener("resize", () => {
                            this.engine.resize();
                        });
                    },

                    createScene: function() {
                        const scene = new BABYLON.Scene(this.engine);
                        
                        // 1. Physics
                        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

                        // 2. Cameras
                        this.cameraOrbit = new BABYLON.ArcRotateCamera("CameraOrbit", -Math.PI / 2, Math.PI / 2.5, 60, BABYLON.Vector3.Zero(), scene);
                        this.cameraOrbit.attachControl(this.canvas, true);
                        this.cameraOrbit.wheelPrecision = 50;
                        this.cameraOrbit.panningSensibility = 0; 

                        this.cameraFree = new BABYLON.UniversalCamera("CameraFree", new BABYLON.Vector3(0, 10, -40), scene);
                        this.cameraFree.setTarget(BABYLON.Vector3.Zero());
                        
                        this.cameraFree.keysUp = [87, 38]; // W
                        this.cameraFree.keysDown = [83, 40]; // S
                        this.cameraFree.keysLeft = [65, 37]; // A
                        this.cameraFree.keysRight = [68, 39]; // D
                        this.cameraFree.speed = 1.0; 
                        this.cameraFree.inertia = 0.6;

                        // 3. Lighting
                        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                        light.intensity = 0.8;
                        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
                        dirLight.intensity = 0.5;

                        // 4. Ground
                        const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 200, height: 200}, scene);
                        const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
                        groundMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.2);
                        groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                        ground.material = groundMat;
                        ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.5, friction: 0.5 }, scene);

                        // 5. Incline
                        const ramp = BABYLON.MeshBuilder.CreateBox("ramp", {width: 15, height: 1, depth: 30}, scene);
                        ramp.position = new BABYLON.Vector3(30, 4, 0); 
                        ramp.rotation.z = Math.PI / 8;
                        const rampMat = new BABYLON.StandardMaterial("rampMat", scene);
                        rampMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.3);
                        ramp.material = rampMat;
                        ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.2, friction: 0.4 }, scene);

                        // 6. Pillars
                        this.createPillars(scene);

                        // 7. Interaction
                        this.setupInteraction(scene);

                        return scene;
                    },

                    // --- KILL ZONE LOGIC ---
                    handleKillZone: function() {
                        const killY = -60;
                        for(let i = spawnedMeshes.length - 1; i >= 0; i--) {
                            const mesh = spawnedMeshes[i];
                            if(mesh && !mesh.isDisposed()) {
                                if(mesh.position.y < killY) {
                                    // If we are riding this object, exit view mode first
                                    if(mesh === viewTargetMesh) {
                                        // This will now trigger the SNAP BACK logic in toggleViewMode
                                        toggleViewMode(); 
                                    }
                                    mesh.dispose();
                                    spawnedMeshes.splice(i, 1);
                                }
                            }
                        }
                    },

                    handleInput: function() {
                        if(selectedShape !== 'freecam' && selectedShape !== 'view') return;
                        if(!this.cameraFree) return;
                        
                        const cam = this.cameraFree;
                        const lookSpeed = 0.02;

                        // 1. LOOKING (Always active for FreeCam/ViewMode)
                        if(lookState.left) cam.rotation.y -= lookSpeed;
                        if(lookState.right) cam.rotation.y += lookSpeed;
                        if(lookState.up) cam.rotation.x -= lookSpeed;
                        if(lookState.down) cam.rotation.x += lookSpeed;

                        // 2. MOVEMENT Logic
                        if (selectedShape === 'view' && viewTargetMesh && viewTargetMesh.physicsImpostor) {
                            // --- VIEW MODE MOVEMENT (Control Object) ---
                            
                            // Snap Camera to Object
                            cam.position.copyFrom(viewTargetMesh.position);
                            cam.position.y += 1.5; // Slightly above center (Eye level)

                            // Force Logic
                            const forcePower = 0.5; // Adjust speed
                            const impulse = BABYLON.Vector3.Zero();

                            // Calculate direction vectors based on Camera Rotation (Y only)
                            const forward = cam.getDirection(BABYLON.Vector3.Forward());
                            const right = cam.getDirection(BABYLON.Vector3.Right());

                            // Flatten to ground plane (No flying)
                            forward.y = 0;
                            forward.normalize();
                            right.y = 0;
                            right.normalize();

                            if(moveState.up) impulse.addInPlace(forward.scale(forcePower));
                            if(moveState.down) impulse.addInPlace(forward.scale(-forcePower));
                            if(moveState.left) impulse.addInPlace(right.scale(-forcePower));
                            if(moveState.right) impulse.addInPlace(right.scale(forcePower));

                            if(!impulse.equals(BABYLON.Vector3.Zero())) {
                                viewTargetMesh.physicsImpostor.applyImpulse(impulse, viewTargetMesh.getAbsolutePosition());
                            }

                        } else if (selectedShape === 'freecam') {
                            // --- STANDARD FREE CAM MOVEMENT ---
                            const moveSpeed = 1.0;
                            if(moveState.up) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Forward()).scale(moveSpeed));
                            if(moveState.down) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Backward()).scale(moveSpeed));
                            if(moveState.left) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Left()).scale(moveSpeed));
                            if(moveState.right) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Right()).scale(moveSpeed));
                        }
                    },

                    switchCamera: function(toFreeCam) {
                        if(!this.scene) return;
                        
                        this.cameraOrbit.detachControl();
                        this.cameraFree.detachControl();

                        if(toFreeCam) {
                            // If we aren't in view mode with a target, copy position
                            // NOTE: If we just exited View Mode via toggleViewMode, the position is already reset
                            if (!viewTargetMesh && selectedShape !== 'view') {
                                // standard free cam behavior
                            }
                            
                            this.scene.activeCamera = this.cameraFree;
                            this.cameraFree.attachControl(this.canvas, true);
                        } else {
                            // Orbit Mode
                            // We use the FreeCamera's current position to place the Orbit Camera
                            this.cameraOrbit.position.copyFrom(this.cameraFree.position);
                            
                            // Calculate a target in front of where we were looking
                            const forward = this.cameraFree.getDirection(BABYLON.Vector3.Forward());
                            const newTarget = this.cameraFree.position.add(forward.scale(20));
                            this.cameraOrbit.setTarget(newTarget);

                            this.scene.activeCamera = this.cameraOrbit;
                            this.cameraOrbit.attachControl(this.canvas, true);
                        }
                    },

                    createPillars: function(scene) {
                        const mat = new BABYLON.StandardMaterial("pillarMat", scene);
                        mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);

                        for(let i=0; i < 15; i++) {
                            const height = 10 + Math.random() * 15;
                            const size = 2 + Math.random() * 3;
                            const pillar = BABYLON.MeshBuilder.CreateBox("pillar" + i, {height: height, width: size, depth: size}, scene);
                            
                            let x = (Math.random() - 0.5) * 160;
                            let z = (Math.random() - 0.5) * 160;
                            if(Math.abs(x) < 20 && Math.abs(z) < 20) { x += 40; }

                            pillar.position = new BABYLON.Vector3(x, height/2, z);
                            pillar.material = mat;
                            pillar.physicsImpostor = new BABYLON.PhysicsImpostor(pillar, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);
                        }
                    },

                    setupInteraction: function(scene) {
                        scene.onPointerObservable.add((pointerInfo) => {
                            switch (pointerInfo.type) {
                                case BABYLON.PointerEventTypes.POINTERDOWN:
                                    if(pointerInfo.event.button !== 0) return; 
                                    if(selectedShape === 'freecam' || selectedShape === 'none') return;

                                    const pickInfo = pointerInfo.pickInfo;
                                    if (pickInfo.hit && pickInfo.pickedMesh) {
                                        const mesh = pickInfo.pickedMesh;

                                        // VIEW MODE SELECTION
                                        if (selectedShape === 'view') {
                                            if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                                viewTargetMesh = mesh;
                                                document.getElementById('txt-instruct').innerHTML = "Controlling Object.<br>WASD to Move. Click Button to Exit.";
                                            }
                                            return;
                                        }

                                        // FREEZE
                                        if (selectedShape === 'freeze') {
                                            if (!mesh.physicsImpostor || mesh.name === "ground" || mesh.name === "ramp") return;

                                            if (freezeAction === 'freeze') {
                                                if(!mesh.metadata) mesh.metadata = {};
                                                if(mesh.physicsImpostor.mass > 0) {
                                                    mesh.metadata.originalMass = mesh.physicsImpostor.mass;
                                                    mesh.metadata.originalColor = mesh.material.diffuseColor.clone();
                                                    mesh.metadata.originalEmissive = mesh.material.emissiveColor.clone();
                                                    mesh.physicsImpostor.setMass(0);
                                                    mesh.physicsImpostor.sleep();
                                                    mesh.material.emissiveColor = new BABYLON.Color3(0.2, 0.6, 1); 
                                                    mesh.material.diffuseColor = new BABYLON.Color3(0.5, 0.8, 1);
                                                    mesh.material.alpha = 0.8;
                                                }
                                            } else {
                                                if(mesh.metadata && mesh.metadata.originalMass) {
                                                    mesh.physicsImpostor.setMass(mesh.metadata.originalMass);
                                                    mesh.physicsImpostor.wakeUp();
                                                    mesh.material.emissiveColor = mesh.metadata.originalEmissive;
                                                    mesh.material.diffuseColor = mesh.metadata.originalColor;
                                                    mesh.material.alpha = 1.0;
                                                    mesh.metadata = null;
                                                }
                                            }
                                            return;
                                        }
                                        
                                        // PUSH
                                        if (selectedShape === 'push') {
                                            if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                                const ray = pickInfo.ray;
                                                const forceDirection = ray.direction;
                                                const forceMagnitude = 50; 
                                                mesh.physicsImpostor.applyImpulse(
                                                    forceDirection.scale(forceMagnitude), 
                                                    pickInfo.pickedPoint
                                                );
                                            }
                                            return; 
                                        }

                                        // SPAWN
                                        const normal = pickInfo.getNormal(true);
                                        if (normal) {
                                            const spawnPos = pickInfo.pickedPoint.add(normal.scale(0.6));
                                            this.spawnObject(selectedShape, spawnPos, scene);
                                        }
                                    }
                                    break;
                            }
                        });
                    },

                    spawnObject: function(type, position, scene) {
                        let mesh;
                        const mat = new BABYLON.StandardMaterial("objMat" + Date.now(), scene);
                        mat.diffuseColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                        const scale = Math.random() * 0.4 + 0.6; 

                        if (type === 'box') {
                            mesh = BABYLON.MeshBuilder.CreateBox("box", {size: scale}, scene);
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, restitution: 0.2, friction: 0.6 }, scene);
                        } 
                        else if (type === 'sphere') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: scale}, scene);
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.7, friction: 0.5 }, scene);
                        }
                        else if (type === 'cylinder') {
                            mesh = BABYLON.MeshBuilder.CreateCylinder("cyl", {height: scale, diameter: scale/2}, scene);
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: 1, restitution: 0.3, friction: 0.6 }, scene);
                        }
                        else if (type === 'bomb' || type === 'frag_bomb') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("bomb", {diameter: 1.2}, scene);
                            mat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1); 
                            mat.emissiveColor = new BABYLON.Color3(0.1, 0, 0); 
                            if (type === 'frag_bomb') mat.emissiveColor = new BABYLON.Color3(0.3, 0.1, 0); 

                            mesh.material = mat;
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 3, restitution: 0.5, friction: 0.8 }, scene);
                            this.armBomb(mesh, scene, type === 'frag_bomb');
                        }

                        if (mesh && !type.includes('bomb')) {
                            mesh.position.copyFrom(position);
                            mesh.material = mat;
                            spawnedMeshes.push(mesh);
                        } else if (mesh) {
                            mesh.position.copyFrom(position);
                            spawnedMeshes.push(mesh);
                        }
                    },

                    armBomb: function(bombMesh, scene, isFragment) {
                        let flashCount = 0;
                        const flashInterval = setInterval(() => {
                            if(!bombMesh || bombMesh.isDisposed()) { clearInterval(flashInterval); return; }
                            const colorOn = isFragment ? new BABYLON.Color3(1, 0.5, 0) : new BABYLON.Color3(1, 0, 0);
                            if (flashCount % 2 === 0) bombMesh.material.emissiveColor = colorOn;
                            else bombMesh.material.emissiveColor = new BABYLON.Color3(0.1, 0, 0);
                            flashCount++;
                        }, 500);

                        setTimeout(() => {
                            clearInterval(flashInterval);
                            if(bombMesh && !bombMesh.isDisposed()) {
                                this.explode(bombMesh.position, scene, isFragment);
                                bombMesh.dispose();
                            }
                        }, 4000);
                    },

                    explode: function(center, scene, isFragment) {
                        const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", {diameter: 1}, scene);
                        explosion.position = center;
                        const expMat = new BABYLON.StandardMaterial("expMat", scene);
                        expMat.diffuseColor = isFragment ? new BABYLON.Color3(1, 0.8, 0) : new BABYLON.Color3(1, 0.5, 0);
                        expMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0);
                        expMat.alpha = 0.8;
                        explosion.material = expMat;

                        let scale = 1;
                        const anim = scene.onBeforeRenderObservable.add(() => {
                            scale += 0.8;
                            explosion.scaling = new BABYLON.Vector3(scale, scale, scale);
                            expMat.alpha -= 0.05;
                            if (expMat.alpha <= 0) {
                                scene.onBeforeRenderObservable.remove(anim);
                                explosion.dispose();
                            }
                        });

                        const blastRadius = 25;
                        const blastForce = 60; 
                        spawnedMeshes.forEach(mesh => {
                            if (mesh && !mesh.isDisposed() && mesh.physicsImpostor) {
                                if (mesh.metadata && mesh.metadata.originalMass) return;
                                const dir = mesh.getAbsolutePosition().subtract(center);
                                const dist = dir.length();
                                if (dist < blastRadius) {
                                    dir.normalize();
                                    const forceMagnitude = blastForce * (1 - dist / blastRadius);
                                    const contactPoint = mesh.getAbsolutePosition();
                                    const impulse = dir.scale(forceMagnitude);
                                    mesh.physicsImpostor.applyImpulse(impulse, contactPoint);
                                }
                            }
                        });

                        if (isFragment) this.spawnFragments(center, scene);
                    },

                    spawnFragments: function(center, scene) {
                        const numFrags = 20;
                        for(let i=0; i<numFrags; i++) {
                            const frag = BABYLON.MeshBuilder.CreateBox("frag", {size: 0.5}, scene);
                            frag.position = center.clone();
                            frag.position.y += 1;
                            frag.position.x += (Math.random() - 0.5);
                            frag.position.z += (Math.random() - 0.5);
                            const fMat = new BABYLON.StandardMaterial("fMat", scene);
                            fMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                            fMat.emissiveColor = new BABYLON.Color3(0.8, 0.3, 0); 
                            frag.material = fMat;
                            frag.physicsImpostor = new BABYLON.PhysicsImpostor(frag, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0.5, restitution: 0.1 }, scene);
                            const exDir = new BABYLON.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5).normalize();
                            frag.physicsImpostor.applyImpulse(exDir.scale(12), frag.getAbsolutePosition());
                            spawnedMeshes.push(frag);
                        }
                    }
                }
            }
        };

        workshop.shaman.sandbox3d.init();

    </script>
</body>
</html>