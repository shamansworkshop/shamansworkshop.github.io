<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sand Box 3D for PC</title>
    
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script> 
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <style>
        /* --- GLOBAL SETUP --- */
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
            cursor: default;
        }

        /* --- UI PANELS --- */
        .ui-panel-base {
            position: absolute;
            width: 250px;
            background: rgba(30, 30, 30, 0.95);
            border-radius: 8px;
            padding: 10px 15px 15px 15px;
            color: #eee;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid #444;
            pointer-events: auto;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 20;
            transition: transform 0.2s ease-in-out, opacity 0.2s;
        }

        /* Scrollbar styling for panels */
        .ui-panel-base::-webkit-scrollbar { width: 6px; }
        .ui-panel-base::-webkit-scrollbar-track { background: #222; }
        .ui-panel-base::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

        #left-panel { top: 20px; left: 20px; }
        #right-panel { top: 20px; right: 20px; }

        /* --- MINIMIZED/HIDDEN STATE --- */
        /* We hide the content or the whole panel based on logic */
        .ui-panel-base.hidden {
            display: none;
        }
        
        .ui-panel-base.minimized {
            width: 140px; 
            height: 35px; 
            overflow: hidden; 
            padding: 0 10px;
            display: flex;
            align-items: center;
        }
        .ui-panel-base.minimized .panel-content { display: none; }
        .ui-panel-base.minimized .panel-header {
            border-bottom: none; 
            margin-bottom: 0; 
            padding-bottom: 0;
            width: 100%;
        }
        .ui-panel-base.minimized h2 { font-size: 13px; }

        /* --- COMPONENTS --- */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        h2 { margin: 0; font-size: 18px; color: #4aa3df; }
        
        .section-label {
            font-size: 11px;
            font-weight: bold;
            color: #888;
            margin-top: 15px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .instruction {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.4;
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #4aa3df;
        }
        .control-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px; }

        .slider-group {
            background: #252525;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            margin-bottom: 10px;
        }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; color: #ddd; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; }
        input[type=color] { width: 100%; height: 30px; border: none; padding: 0; background: none; cursor: pointer; }

        /* --- BUTTONS --- */
        button {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            text-align: left;
            display: flex;
            align-items: center;
            font-size: 13px;
            width: 100%; 
            transition: background 0.1s;
        }
        button:hover { background: #444; border-color: #777; }
        button.active { background: #2a5c80; border-color: #4aa3df; font-weight: bold; }

        .btn-minimize {
            width: 24px; height: 24px; padding: 0;
            display: flex; justify-content: center; align-items: center;
            font-size: 18px; line-height: 1;
            background: transparent; border: 1px solid #555;
        }

        /* --- FLASHBANG OVERLAY --- */
        #flash-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 9999; /* Above everything */
            pointer-events: none; /* Let clicks pass through */
            opacity: 0;
            /* Changed from Flex to Block so the image can stretch freely */
            display: block; 
        }
        
        #flash-meme-img {
            /* FORCE FULL SCREEN */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            
            /* 'fill' stretches the image to hit every corner (might distort). 
               Change to 'cover' if you want to keep aspect ratio but crop edges. */
            object-fit: fill; 
            
            display: none; /* Hidden during the "White" flash phase */
        }

        /* Flashbang Button Color */
        button#btn-flashbang { border-left: 4px solid #f1c40f; }
        button#btn-flashbang.active { background: #635a2d; border-color: #f1c40f; }
        
        /* Icon for Flashbang */
        .icon-flash { 
            background: #f1c40f; 
            width: 8px; height: 14px; 
            border-radius: 2px; 
            border: 1px solid #fff;
        }

        button#btn-enter-game { background: #27ae60; border-color: #2ecc71; justify-content: center; font-weight: bold; margin-bottom: 5px; }
        button#btn-upload { background: #333; border-color: #888; justify-content: center; font-weight: bold; margin-bottom: 10px; margin-top: 5px; }
        button#btn-upload:hover { background: #555; border-color: #aaa; }

        button#btn-clear { background: #6e2828; border-color: #a34a4a; justify-content: center; font-weight: bold; margin-top: 10px; }

        /* Button Colors */
        button#btn-none, button#btn-none-tools { border-left: 4px solid #aaa; }
        button#btn-push { border-left: 4px solid #2ecc71; }
        button#btn-eraser { border-left: 4px solid #ff5252; }
        button#btn-view { border-left: 4px solid #9b59b6; }
        button#btn-freeze { border-left: 4px solid #3498db; }
        button#btn-build { border-left: 4px solid #e91e63; }
        button#btn-freeze.thaw-mode { border-left-color: #e67e22; }
        button#btn-freeze.thaw-mode.active { background: #a04000; border-color: #e67e22; }

        /* Custom Model Button */
        button#btn-custom { border-left: 4px solid #f39c12; }

        /* Explosives */
        button.btn-explosive { border-left: 4px solid #e74c3c; }
        button.btn-explosive.active { background: #802a2a; border-color: #df4a4a; }
        button#btn-frag { border-left: 4px solid #d35400; }

        /* --- ICONS --- */
        .shape-icon { width: 12px; height: 12px; margin-right: 10px; background: #ccc; display: inline-block; }
        .icon-box { border-radius: 2px; }
        .icon-sphere { border-radius: 50%; }
        .icon-cyl { border-radius: 2px; height: 16px; width: 8px; }
        .icon-tri { 
            width: 0; height: 0; background: transparent; 
            border-left: 6px solid transparent; border-right: 6px solid transparent; 
            border-bottom: 12px solid #ccc; 
        }
        .icon-bomb { border-radius: 50%; background: #e74c3c; border: 1px solid #000; }
        .icon-frag { border-radius: 50%; background: #d35400; border: 2px dashed #000; }
        .icon-custom { background: #f39c12; border-radius: 3px; border: 1px solid #fff; }
        
        .icon-hand { background: transparent; border: 1px solid #2ecc71; width: 10px; height: 10px;}
        .icon-cam { background: transparent; border: 2px solid #f1c40f; width: 12px; height: 8px; border-radius: 2px; }
        .icon-eye { background: transparent; border: 2px solid #9b59b6; border-radius: 50%; width: 12px; height: 6px; margin-top: 3px; position: relative; }
        .icon-eye::after { content:''; position: absolute; left: 3px; top: 0; width: 4px; height: 4px; background: #9b59b6; border-radius: 50%; }
        .icon-ice { background: #3498db; transform: rotate(45deg); width: 8px; height: 8px; }
        .icon-glue { background: #e91e63; width: 10px; height: 4px; border-radius: 1px; }
        .icon-eraser { background: white; transform: rotate(45deg); width: 10px; height: 6px; border: 1px solid #aaa; }
        .icon-x { background: transparent; color: #aaa; font-weight: bold; font-size: 14px; line-height: 10px; width: auto; height: auto; }
        .icon-play { background: transparent; border-left: 10px solid white; border-top: 6px solid transparent; border-bottom: 6px solid transparent; width: 0; height: 0; margin-right: 5px; }
        .icon-upload { background: transparent; width: 12px; height: 12px; border-bottom: 2px solid #ccc; position: relative; }
        .icon-upload::after { content:''; position: absolute; left: 3px; top: -2px; width: 0; height: 0; border-left: 3px solid transparent; border-right: 3px solid transparent; border-bottom: 6px solid #ccc; }

        /* Crosshair for FPS mode */
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 2px black;
            opacity: 0; /* Hidden by default until locked */
            transition: opacity 0.2s;
        }

    </style>
</head>
<body>

    <input type="file" id="file-input" accept=".glb,.gltf,.obj" style="display: none;" onchange="handleFileUpload(this)">
    
    <div id="flash-layer">
        <img id="flash-meme-img"
            src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExb2w3dmxjaDVxaXY1NWdoZ3ppd3EzcTU5enRnMTFhdHcxbXd2NHllayZlcD12MV9naWZzX3NlYXJjaCZjdD1n/ze4Y13PeotDfqoQWza/giphy.gif"
            alt="get flashbanged lol">
    </div>

    <div id="crosshair"></div>

    <div id="left-panel" class="ui-panel-base minimized">
        <div class="panel-header">
            <h2>Tools [Q]</h2>
            <button class="btn-minimize" id="btn-min-left" onclick="toggleLeftUI()" title="Toggle Menu">+</button>
        </div>

        <div class="panel-content">
            <button id="btn-enter-game" onclick="enterGame()">
                <span class="shape-icon icon-play"></span> FULLSCREEN
            </button>

            <button id="btn-upload" onclick="triggerUpload()">
                <span class="shape-icon icon-upload"></span> Upload 3D Model
            </button>
            
            <div class="instruction">
                <span id="txt-instruct">
                    <b>WASD</b>: Fly &nbsp;|&nbsp; <b>L-SHIFT</b>: Toggle Mouse<br>
                    <b>Q</b>: Tools Panel &nbsp;|&nbsp; <b>E</b>: Objects Panel<br>
                    <b>Click</b>: Use Tool
                </span>
            </div>

            <div class="section-label">Actions</div>
            <div class="control-group">
                <button id="btn-none-tools" onclick="selectShape('none')">
                    <span class="shape-icon icon-x">X</span> None (Safe Mode)
                </button>

                <button id="btn-view" onclick="toggleViewMode()">
                    <span class="shape-icon icon-eye"></span> Possess Object
                </button>
                <button id="btn-push" onclick="selectShape('push')">
                    <span class="shape-icon icon-hand"></span> Force Push
                </button>
                <button id="btn-eraser" onclick="selectShape('eraser')">
                    <span class="shape-icon icon-eraser"></span> Eraser
                </button>
                <button id="btn-freeze" onclick="toggleFreezeLogic()">
                    <span class="shape-icon icon-ice"></span> Freeze
                </button>
                <button id="btn-build" onclick="toggleBuildMode()">
                    <span class="shape-icon icon-glue"></span> Build Mode
                </button>
            </div>
            
            <button id="btn-clear" onclick="clearObjects()">CLEAR ALL</button>
        </div>
    </div>

    <div id="right-panel" class="ui-panel-base minimized">
        <div class="panel-header">
            <h2>Objects [E]</h2>
            <button class="btn-minimize" id="btn-min-right" onclick="toggleRightUI()" title="Toggle Menu">+</button>
        </div>

        <div class="panel-content">
            
            <div class="section-label">Selection</div>
            <div class="control-group">
                 <button id="btn-none" onclick="selectShape('none')">
                    <span class="shape-icon icon-x">X</span> None (Safe Mode)
                </button>
            </div>

            <div class="section-label">Properties</div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Size</span>
                    <span id="size-display">1.0</span>
                </div>
                <input type="range" id="size-slider" min="0.2" max="5.0" step="0.1" value="1.0" oninput="updateSize(this.value)">
            </div>
            
            <div class="slider-group">
                <div class="slider-label"><span>Color</span></div>
                <input type="color" id="color-picker" value="#3498db">
            </div>

            <div id="custom-model-container" style="display: none;">
                <div class="section-label">Custom</div>
                <div class="control-group">
                    <button id="btn-custom" onclick="selectShape('custom')">
                        <span class="shape-icon icon-custom"></span> <span id="custom-name">Spawn Upload</span>
                    </button>
                </div>
            </div>

            <div class="section-label">Shapes</div>
            <div class="control-group">
                <button id="btn-box" class="active" onclick="selectShape('box')">
                    <span class="shape-icon icon-box"></span> Cube
                </button>
                <button id="btn-sphere" onclick="selectShape('sphere')">
                    <span class="shape-icon icon-sphere"></span> Sphere
                </button>
                <button id="btn-cyl" onclick="selectShape('cylinder')">
                    <span class="shape-icon icon-cyl"></span> Cylinder
                </button>
                <button id="btn-tri" onclick="selectShape('triangle')">
                    <span class="shape-icon icon-tri"></span> Triangle
                </button>
            </div>

            <div class="section-label">Explosives</div>
            <div class="control-group">
                <button id="btn-bomb" class="btn-explosive" onclick="selectShape('bomb')">
                    <span class="shape-icon icon-bomb"></span> Bomb
                </button>
                <button id="btn-frag" class="btn-explosive" onclick="selectShape('frag_bomb')">
                    <span class="shape-icon icon-frag"></span> Cluster Bomb
                </button>
                <button id="btn-flashbang" onclick="selectShape('flashbang')">
                    <span class="shape-icon icon-flash"></span> Flashbang
                </button>
            </div>

        </div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
        // ==========================================
        // SECTION 1: UI & INTERACTION LOGIC
        // ==========================================
        
        let selectedShape = 'box'; 
        let freezeAction = 'freeze'; 
        let isBuildMode = false; 
        let currentSize = 1.0; 
        let spawnedMeshes = [];    
        let sceneRef = null;
        let viewTargetMesh = null; 
        
        let customModelTemplate = null; 

        // Movement State
        const moveState = { up: false, down: false, left: false, right: false };
        const lookState = { up: false, down: false, left: false, right: false }; // Kept for Arrows backup

        // --- PC KEYBOARD CONTROLS ---
        window.addEventListener('keydown', (e) => {
            const k = e.code;
            
            // Movement
            if(k === 'KeyW') moveState.up = true;
            if(k === 'KeyS') moveState.down = true;
            if(k === 'KeyA') moveState.left = true;
            if(k === 'KeyD') moveState.right = true;
            
            // Look (Backup)
            if(k === "ArrowUp") lookState.up = true;
            if(k === "ArrowDown") lookState.down = true;
            if(k === "ArrowLeft") lookState.left = true;
            if(k === "ArrowRight") lookState.right = true;

            // Panel Toggles
            if (k === 'KeyQ') toggleLeftUI();
            if (k === 'KeyE') toggleRightUI();

            // Cursor Lock Switch
            if (k === 'ShiftLeft') toggleCursorLock();
        });

        window.addEventListener('keyup', (e) => {
            const k = e.code;
            if(k === 'KeyW') moveState.up = false;
            if(k === 'KeyS') moveState.down = false;
            if(k === 'KeyA') moveState.left = false;
            if(k === 'KeyD') moveState.right = false;
            if(k === "ArrowUp") lookState.up = false;
            if(k === "ArrowDown") lookState.down = false;
            if(k === "ArrowLeft") lookState.left = false;
            if(k === "ArrowRight") lookState.right = false;
        });

        // --- CURSOR LOCK LOGIC ---
        function toggleCursorLock() {
            const canvas = document.getElementById("renderCanvas");
            if (document.pointerLockElement === canvas) {
                document.exitPointerLock();
            } else {
                canvas.requestPointerLock();
            }
        }

        // Handle Pointer Lock State Change to update UI
        document.addEventListener('pointerlockchange', () => {
            const crosshair = document.getElementById('crosshair');
            const canvas = document.getElementById("renderCanvas");
            
            if (document.pointerLockElement === canvas) {
                // LOCKED
                crosshair.style.opacity = '1';
                document.getElementById('txt-instruct').style.color = "#4aa3df";
            } else {
                // UNLOCKED
                crosshair.style.opacity = '0';
                document.getElementById('txt-instruct').style.color = "#aaa";
            }
        });

        function enterGame() {
            const de = document.documentElement;
            if (de.requestFullscreen) de.requestFullscreen();
            else if (de.webkitRequestFullscreen) de.webkitRequestFullscreen();
        }

        function triggerUpload() {
            document.getElementById('file-input').click();
        }

        function handleFileUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const blobUrl = URL.createObjectURL(file);
                const ext = file.name.split('.').pop().toLowerCase();
                
                if(sceneRef) {
                    document.getElementById('custom-name').innerText = file.name.length > 15 ? file.name.substring(0,12) + "..." : file.name;

                    BABYLON.SceneLoader.ImportMesh("", "", blobUrl, sceneRef, 
                        function (meshes, particleSystems, skeletons) {
                            if(meshes.length === 0) return;

                            let min = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                            let max = new BABYLON.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

                            meshes.forEach(m => {
                                m.setParent(null); 
                                const b = m.getHierarchyBoundingVectors();
                                min = BABYLON.Vector3.Minimize(min, b.min);
                                max = BABYLON.Vector3.Maximize(max, b.max);
                            });

                            const width = max.x - min.x;
                            const height = max.y - min.y;
                            const depth = max.z - min.z;
                            const center = min.add(max).scale(0.5);

                            const hitBox = BABYLON.MeshBuilder.CreateBox("customHitbox", {width: width, height: height, depth: depth}, sceneRef);
                            hitBox.isVisible = false; 
                            
                            meshes.forEach(m => {
                                m.parent = hitBox;
                                m.position = m.position.subtract(center);
                            });

                            hitBox.setEnabled(false);
                            
                            if (customModelTemplate && customModelTemplate.mesh) {
                                customModelTemplate.mesh.dispose();
                            }

                            customModelTemplate = {
                                mesh: hitBox,
                                dimensions: { width, height, depth }
                            };

                            document.getElementById('custom-model-container').style.display = 'block';
                            selectShape('custom');
                            
                            // Open objects panel if hidden
                            const right = document.getElementById('right-panel');
                            if(right.classList.contains('minimized')) toggleRightUI();

                            input.value = "";
                        }, 
                        null, 
                        function (scene, message, exception) {
                            console.error("Error loading file:", message);
                            alert("Failed to load model.");
                        },
                        "." + ext
                    );
                }
            }
        }

        function toggleLeftUI() {
            const left = document.getElementById('left-panel');
            const leftBtn = document.getElementById('btn-min-left');
            const isMinimizing = !left.classList.contains('minimized');
            
            if (isMinimizing) {
                left.classList.add('minimized');
                leftBtn.innerText = "+";
            } else {
                left.classList.remove('minimized');
                leftBtn.innerText = "-";
            }
        }

        function toggleRightUI() {
            const right = document.getElementById('right-panel');
            const rightBtn = document.getElementById('btn-min-right');
            const isMinimizing = !right.classList.contains('minimized');

            if (isMinimizing) {
                right.classList.add('minimized');
                rightBtn.innerText = "+";
            } else {
                right.classList.remove('minimized');
                rightBtn.innerText = "-";
            }
        }

        function toggleBuildMode() {
            if(selectedShape === 'none' || selectedShape === 'eraser' || selectedShape === 'push' || selectedShape === 'view') {
                selectShape('box');
                isBuildMode = true; 
            } else {
                isBuildMode = !isBuildMode; 
            }

            const btn = document.getElementById('btn-build');
            if(isBuildMode) btn.classList.add('active');
            else btn.classList.remove('active');
        }

        function selectShape(shape) {
            selectedShape = shape;
            const instruct = document.getElementById('txt-instruct');
            
            document.querySelectorAll('button').forEach(b => {
                if(!b.classList.contains('btn-minimize') && b.id !== 'btn-enter-game' && b.id !== 'btn-build' && b.id !== 'btn-upload') {
                    b.classList.remove('active');
                }
            });

            if (shape === 'none') {
                isBuildMode = false;
                document.getElementById('btn-build').classList.remove('active');
            }

            if (shape === 'view') {
                workshop.shaman.sandbox3d.resetCameraTarget();
            }
            else {
                viewTargetMesh = null;
            }

            let btnId = 'btn-' + shape;
            if (shape === 'cylinder') btnId = 'btn-cyl';
            if (shape === 'triangle') btnId = 'btn-tri';
            if (shape === 'frag_bomb') btnId = 'btn-frag';
            if (shape === 'flashbang') btnId = 'btn-flashbang';
            
            const activeBtn = document.getElementById(btnId);
            if(activeBtn) activeBtn.classList.add('active');

            if (shape === 'none') {
                 const btnTools = document.getElementById('btn-none-tools');
                 if(btnTools) btnTools.classList.add('active');
                 const btnRight = document.getElementById('btn-none');
                 if(btnRight) btnRight.classList.add('active');
            }

            if(shape === 'freeze' && freezeAction === 'thaw') {
                document.getElementById('btn-freeze').classList.add('thaw-mode');
            }
        }

        function updateSize(val) {
            currentSize = parseFloat(val);
            document.getElementById('size-display').innerText = currentSize.toFixed(1);
        }

        function toggleFreezeLogic() {
            const btn = document.getElementById('btn-freeze');
            if(selectedShape === 'freeze') {
                if(freezeAction === 'freeze') {
                    freezeAction = 'thaw';
                    btn.innerHTML = '<span class="shape-icon icon-ice" style="background:#e67e22"></span> Unfreeze';
                    btn.classList.add('thaw-mode');
                } else {
                    freezeAction = 'freeze';
                    btn.innerHTML = '<span class="shape-icon icon-ice"></span> Freeze';
                    btn.classList.remove('thaw-mode');
                }
            } else {
                selectShape('freeze');
            }
        }

        function toggleViewMode() {
            if(selectedShape === 'view') {
                viewTargetMesh = null;
                selectShape('box'); 
            } else {
                selectShape('view');
            }
        }

        function clearObjects() {
            if (!sceneRef) return;
            if(selectedShape === 'view') toggleViewMode();
            viewTargetMesh = null;
            spawnedMeshes.forEach(mesh => { if(mesh && !mesh.isDisposed()) mesh.dispose(); });
            spawnedMeshes = [];
        }

        // ==========================================
        // SECTION 2: BABYLON 3D ENGINE
        // ==========================================

        const workshop = {
            shaman: {
                sandbox3d: {
                    canvas: document.getElementById("renderCanvas"),
                    engine: null,
                    scene: null,
                    cameraFree: null,

                    init: function() {
                        this.engine = new BABYLON.Engine(this.canvas, true);
                        this.scene = this.createScene();
                        sceneRef = this.scene;

                        this.engine.runRenderLoop(() => {
                            this.handleKillZone(); 
                            this.handleInput();    
                            this.scene.render();
                        });
                        window.addEventListener("resize", () => { this.engine.resize(); });
                    },

                    createScene: function() {
                        const scene = new BABYLON.Scene(this.engine);
                        // Standard gravity
                        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

                        this.cameraFree = new BABYLON.UniversalCamera("CameraFree", new BABYLON.Vector3(0, 20, -40), scene);
                        this.cameraFree.setTarget(BABYLON.Vector3.Zero());
                        this.cameraFree.fov = 1.2;
                         
                        // Detach default key controls to prevent conflicts
                        this.cameraFree.keysUp = [];
                        this.cameraFree.keysDown = [];
                        this.cameraFree.keysLeft = [];
                        this.cameraFree.keysRight = [];
                        
                        // We do NOT attach default controls because we are handling rotation manually via PointerLock
                        // this.cameraFree.attachControl(this.canvas, true);
                        
                        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                        light.intensity = 0.8;
                        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
                        dirLight.intensity = 0.5;

                        const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 200, height: 200}, scene);
                        const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
                        groundMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.2);
                        groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                        ground.material = groundMat;
                        ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.5, friction: 0.5 }, scene);

                        const ramp = BABYLON.MeshBuilder.CreateBox("ramp", {width: 15, height: 1, depth: 30}, scene);
                        ramp.position = new BABYLON.Vector3(30, 4, 0); 
                        ramp.rotation.z = Math.PI / 8;
                        const rampMat = new BABYLON.StandardMaterial("rampMat", scene);
                        rampMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.3);
                        ramp.material = rampMat;
                        ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.2, friction: 0.4 }, scene);

                        this.createPillars(scene);
                        this.setupInteraction(scene);
                        return scene;
                    },

                    resetCameraTarget: function() { },

                    handleKillZone: function() {
                        const killY = -100;
                        for(let i = spawnedMeshes.length - 1; i >= 0; i--) {
                            const mesh = spawnedMeshes[i];
                            if(mesh && !mesh.isDisposed()) {
                                if(mesh.position.y < killY) {
                                    if(mesh === viewTargetMesh) toggleViewMode();
                                    mesh.dispose();
                                    spawnedMeshes.splice(i, 1);
                                }
                            }
                        }
                    },

                    handleInput: function() {
                        if(!this.cameraFree) return;
                        
                        const cam = this.cameraFree;
                        const moveSpeed = 0.5;
                        const lookSpeed = 0.03; // For Arrow Keys backup

                        // Arrow Key Look (Backup if mouse lock isn't used)
                        if(lookState.left) cam.rotation.y -= lookSpeed;
                        if(lookState.right) cam.rotation.y += lookSpeed;
                        if(lookState.up) cam.rotation.x -= lookSpeed;
                        if(lookState.down) cam.rotation.x += lookSpeed;

                        if (selectedShape === 'view' && viewTargetMesh && viewTargetMesh.physicsImpostor) {
                            cam.position.copyFrom(viewTargetMesh.position);
                            cam.position.y += (3.0 * (currentSize || 1)); 

                            const forcePower = 0.5 * (viewTargetMesh.physicsImpostor.mass); 
                            const impulse = BABYLON.Vector3.Zero();
                            const forward = cam.getDirection(BABYLON.Vector3.Forward());
                            const right = cam.getDirection(BABYLON.Vector3.Right());
                            forward.y = 0; forward.normalize();
                            right.y = 0; right.normalize();

                            if(moveState.up) impulse.addInPlace(forward.scale(forcePower));
                            if(moveState.down) impulse.addInPlace(forward.scale(-forcePower));
                            if(moveState.left) impulse.addInPlace(right.scale(-forcePower));
                            if(moveState.right) impulse.addInPlace(right.scale(forcePower));

                            if(!impulse.equals(BABYLON.Vector3.Zero())) {
                                viewTargetMesh.physicsImpostor.applyImpulse(impulse, viewTargetMesh.getAbsolutePosition());
                            }
                        } else {
                            if(moveState.up) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Forward()).scale(moveSpeed));
                            if(moveState.down) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Backward()).scale(moveSpeed));
                            if(moveState.left) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Left()).scale(moveSpeed));
                            if(moveState.right) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Right()).scale(moveSpeed));
                        }
                    },

                    createPillars: function(scene) {
                        const mat = new BABYLON.StandardMaterial("pillarMat", scene);
                        mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);

                        for(let i=0; i < 15; i++) {
                            const height = 10 + Math.random() * 15;
                            const size = 2 + Math.random() * 3;
                            const pillar = BABYLON.MeshBuilder.CreateBox("pillar" + i, {height: height, width: size, depth: size}, scene);
                            let x = (Math.random() - 0.5) * 160;
                            let z = (Math.random() - 0.5) * 160;
                            if(Math.abs(x) < 20 && Math.abs(z) < 20) { x += 40; }
                            pillar.position = new BABYLON.Vector3(x, height/2, z);
                            pillar.material = mat;
                            pillar.physicsImpostor = new BABYLON.PhysicsImpostor(pillar, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1 }, scene);
                        }
                    },

                    setupInteraction: function(scene) {
                        // Mouse Look Logic using Pointer Movement
                        document.addEventListener("mousemove", (event) => {
                            if (document.pointerLockElement === this.canvas) {
                                if(this.cameraFree) {
                                    const sensitivity = 0.002;
                                    this.cameraFree.rotation.y += event.movementX * sensitivity;
                                    this.cameraFree.rotation.x += event.movementY * sensitivity;
                                }
                            }
                        });

                        // Click Interaction
                        scene.onPointerObservable.add((pointerInfo) => {
                            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                                if(pointerInfo.event.button !== 0) return; // Only Left Click
                                if(selectedShape === 'none') return; 

                                // If locked, always pick center of screen. If unlocked, pick under mouse
                                let pickInfo;
                                if (document.pointerLockElement === this.canvas) {
                                     pickInfo = scene.pick(this.canvas.width / 2, this.canvas.height / 2);
                                } else {
                                     pickInfo = pointerInfo.pickInfo;
                                }

                                if (pickInfo && pickInfo.hit && pickInfo.pickedMesh) {
                                    // Handle Interaction with loaded models
                                    let mesh = pickInfo.pickedMesh;
                                    if(mesh.parent && (mesh.parent.name.includes("customHitbox") || mesh.parent.name.includes("customInstance"))) {
                                        mesh = mesh.parent;
                                    }

                                    if (selectedShape === 'view') {
                                        if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                            viewTargetMesh = mesh;
                                        }
                                        return;
                                    }

                                    if (selectedShape === 'eraser') {
                                        if (mesh.name === "ground" || mesh.name === "ramp") return; 
                                        mesh.dispose();
                                        const index = spawnedMeshes.indexOf(mesh);
                                        if (index > -1) spawnedMeshes.splice(index, 1);
                                        return;
                                    }

                                    if (selectedShape === 'freeze') {
                                        if (!mesh.physicsImpostor || mesh.name === "ground" || mesh.name === "ramp") return;
                                        if (freezeAction === 'freeze') {
                                            if(!mesh.metadata) mesh.metadata = {};
                                            if(mesh.physicsImpostor.mass > 0) {
                                                mesh.metadata.originalMass = mesh.physicsImpostor.mass;
                                                mesh.physicsImpostor.setMass(0);
                                                mesh.physicsImpostor.sleep();
                                                if(mesh.material) {
                                                    mesh.metadata.originalColor = mesh.material.diffuseColor ? mesh.material.diffuseColor.clone() : null;
                                                    if(mesh.material.emissiveColor) mesh.material.emissiveColor = new BABYLON.Color3(0.2, 0.6, 1);
                                                }
                                            }
                                        } else {
                                            if(mesh.metadata && mesh.metadata.originalMass) {
                                                mesh.physicsImpostor.setMass(mesh.metadata.originalMass);
                                                mesh.physicsImpostor.wakeUp();
                                                if(mesh.material && mesh.metadata.originalColor) {
                                                    if(mesh.material.diffuseColor) mesh.material.diffuseColor = mesh.metadata.originalColor;
                                                    if(mesh.material.emissiveColor) mesh.material.emissiveColor = new BABYLON.Color3(0,0,0);
                                                }
                                                mesh.metadata = null;
                                            }
                                        }
                                        return;
                                    }
                                    
                                    if (selectedShape === 'push') {
                                        if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                            const ray = pickInfo.ray;
                                            const forceDirection = ray.direction;
                                            const forceMagnitude = 50 * (mesh.scaling.x); 
                                            mesh.physicsImpostor.applyImpulse(forceDirection.scale(forceMagnitude), pickInfo.pickedPoint);
                                        }
                                        return; 
                                    }
                                    
                                    this.spawnObject(selectedShape, pickInfo, scene);
                                }
                            }
                        });
                        
                        window.addEventListener("contextmenu", e => e.preventDefault());
                    },

                    spawnObject: function(type, pickInfo, scene) {
                        const normal = pickInfo.getNormal(true);
                        if(!normal) return;

                        let mesh;
                        const mat = new BABYLON.StandardMaterial("objMat" + Date.now(), scene);
                        
                        const pickerVal = document.getElementById('color-picker').value;
                        mat.diffuseColor = BABYLON.Color3.FromHexString(pickerVal);
                        
                        const scale = currentSize; 
                        const pivotOffset = scale * 0.5 + (isBuildMode ? 0 : 0.01);
                        const spawnPos = pickInfo.pickedPoint.add(normal.scale(pivotOffset));

                        if (type === 'custom' && customModelTemplate) {
                            mesh = customModelTemplate.mesh.clone("customInstance_" + Date.now());
                            mesh.setEnabled(true);
                            mesh.scaling = new BABYLON.Vector3(scale, scale, scale);
                            const customOffset = (customModelTemplate.dimensions.height * scale) / 2;
                            mesh.position = pickInfo.pickedPoint.add(normal.scale(customOffset));
                        }
                        else if (type === 'box') {
                            mesh = BABYLON.MeshBuilder.CreateBox("box", {size: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                        } 
                        else if (type === 'sphere') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'cylinder') {
                            mesh = BABYLON.MeshBuilder.CreateCylinder("cyl", {height: scale, diameter: scale/2}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'triangle') {
                            mesh = BABYLON.MeshBuilder.CreateCylinder("tri", {height: scale, diameter: scale, tessellation: 3}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'bomb' || type === 'frag_bomb') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("bomb", {diameter: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                            mat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1); 
                            mat.emissiveColor = new BABYLON.Color3(0.1, 0, 0); 
                            if (type === 'frag_bomb') mat.emissiveColor = new BABYLON.Color3(0.3, 0.1, 0); 
                        }

                        // --- NEW FLASHBANG MESH ---
                        else if (type === 'flashbang') {
                            // Flashbangs look like canisters (Cylinders)
                            mesh = BABYLON.MeshBuilder.CreateCylinder("flashbang", { height: scale * 1.5, diameter: scale * 0.5 }, scene);
                            mesh.position.copyFrom(spawnPos);
                            // Flashbang color (Yellow/White tip)
                            mat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                            mat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0);
                        }

                        if (mesh) {
                            if(type !== 'custom') mesh.material = mat; 
                            
                            let massVal = scale * 1.5;
                            
                            if (type === 'custom' && customModelTemplate) {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 5 * scale, restitution: 0.1, friction: 0.5 }, scene);
                            }
                            else if (type === 'box') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: massVal, restitution: 0.1, friction: 0.8 }, scene);
                            } else if (type === 'sphere' || type.includes('bomb')) {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass: massVal, restitution: 0.4, friction: 0.5 }, scene);
                            } else if (type === 'cylinder' || type === 'triangle') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: massVal, restitution: 0.1, friction: 0.8 }, scene);
                            }
                            else if (type === 'flashbang') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: massVal, restitution: 0.3, friction: 0.5 }, scene);
                                this.armBomb(mesh, scene, false, true); // Pass 'true' for isFlash
                            }

                            if (type.includes('bomb')) this.armBomb(mesh, scene, type === 'frag_bomb');
                            
                            if(isBuildMode && pickInfo.pickedMesh && pickInfo.pickedMesh.physicsImpostor && !type.includes('bomb')) {
                                const joint = new BABYLON.PhysicsJoint(BABYLON.PhysicsJoint.LockJoint, {});
                                pickInfo.pickedMesh.physicsImpostor.addJoint(mesh.physicsImpostor, joint);
                                if(mesh.material) mesh.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                            }
                            spawnedMeshes.push(mesh);
                        }
                    },

                    armBomb: function (bombMesh, scene, isFragment, isFlash = false) {
                        let flashCount = 0;
                        const flashInterval = setInterval(() => {
                            if (!bombMesh || bombMesh.isDisposed()) { clearInterval(flashInterval); return; }

                            // Visual countdown colors
                            let colorOn = new BABYLON.Color3(1, 0, 0); // Default Red
                            if (isFragment) colorOn = new BABYLON.Color3(1, 0.5, 0); // Orange
                            if (isFlash) colorOn = new BABYLON.Color3(1, 1, 1); // White for Flashbang

                            if (flashCount % 2 === 0) bombMesh.material.emissiveColor = colorOn;
                            else bombMesh.material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                            flashCount++;
                        }, isFlash ? 200 : 500); // Flashbangs beep faster

                        setTimeout(() => {
                            clearInterval(flashInterval);
                            if (bombMesh && !bombMesh.isDisposed()) {
                                // Trigger explosion or flash
                                if (isFlash) this.triggerFlashbang(bombMesh.position, scene);
                                else this.explode(bombMesh.position, scene, isFragment, bombMesh.scaling.x);

                                bombMesh.dispose();
                            }
                        }, isFlash ? 2500 : 4000); // Flashbangs explode sooner (2.5s)
                    },

                    explode: function(center, scene, isFragment, scaleMultiplier) {
                        const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", {diameter: 1 * scaleMultiplier}, scene);
                        explosion.position = center;
                        const expMat = new BABYLON.StandardMaterial("expMat", scene);
                        expMat.diffuseColor = isFragment ? new BABYLON.Color3(1, 0.8, 0) : new BABYLON.Color3(1, 0.5, 0);
                        expMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0);
                        expMat.alpha = 0.8;
                        explosion.material = expMat;

                        let scale = 1;
                        const anim = scene.onBeforeRenderObservable.add(() => {
                            scale += 0.8;
                            explosion.scaling = new BABYLON.Vector3(scale, scale, scale);
                            expMat.alpha -= 0.05;
                            if (expMat.alpha <= 0) {
                                scene.onBeforeRenderObservable.remove(anim);
                                explosion.dispose();
                            }
                        });

                        const blastRadius = 25 * scaleMultiplier;
                        const blastForce = 60 * scaleMultiplier; 
                        spawnedMeshes.forEach(mesh => {
                            if (mesh && !mesh.isDisposed() && mesh.physicsImpostor) {
                                if (mesh.metadata && mesh.metadata.originalMass) return;
                                const dir = mesh.getAbsolutePosition().subtract(center);
                                const dist = dir.length();
                                if (dist < blastRadius) {
                                    dir.normalize();
                                    const forceMagnitude = blastForce * (1 - dist / blastRadius);
                                    const contactPoint = mesh.getAbsolutePosition();
                                    const impulse = dir.scale(forceMagnitude);
                                    mesh.physicsImpostor.applyImpulse(impulse, contactPoint);
                                }
                            }
                        });

                        if (isFragment) this.spawnFragments(center, scene);
                    },

                    triggerFlashbang: function (center, scene) {
                        // 1. Physical Knockback (Small pop)
                        this.explode(center, scene, false, 0.2);

                        // 2. THE SCREEN TAKEOVER
                        const layer = document.getElementById('flash-layer');
                        const meme = document.getElementById('flash-meme-img');

                        // PHASE 1: PURE WHITE FLASH
                        layer.style.transition = 'none';
                        layer.style.backgroundColor = 'white';
                        layer.style.opacity = '1';
                        meme.style.display = 'none';

                        // PHASE 2: THE IMAGE (After 150ms)
                        setTimeout(() => {
                            layer.style.backgroundColor = 'black'; // Dark background for the image
                            meme.style.display = 'block';
                        }, 150);

                        // PHASE 3: FADE OUT (After 2.5 seconds)
                        setTimeout(() => {
                            layer.style.transition = 'opacity 2s ease-out';
                            layer.style.opacity = '0';
                        }, 2500);

                        // Cleanup after fade to keep DOM clean
                        setTimeout(() => {
                            meme.style.display = 'none';
                        }, 4500);
                    },

                    spawnFragments: function(center, scene) {
                        const numFrags = 20;
                        for(let i=0; i<numFrags; i++) {
                            const frag = BABYLON.MeshBuilder.CreateBox("frag", {size: 0.5}, scene);
                            frag.position = center.clone();
                            frag.position.y += 1;
                            frag.position.x += (Math.random() - 0.5);
                            frag.position.z += (Math.random() - 0.5);
                            const fMat = new BABYLON.StandardMaterial("fMat", scene);
                            fMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                            fMat.emissiveColor = new BABYLON.Color3(0.8, 0.3, 0); 
                            frag.material = fMat;
                            frag.physicsImpostor = new BABYLON.PhysicsImpostor(frag, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0.5, restitution: 0.1 }, scene);
                            const exDir = new BABYLON.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5).normalize();
                            frag.physicsImpostor.applyImpulse(exDir.scale(12), frag.getAbsolutePosition());
                            spawnedMeshes.push(frag);
                        }
                    }
                }
            }
        };

        workshop.shaman.sandbox3d.init();

    </script>
</body>
</html>
