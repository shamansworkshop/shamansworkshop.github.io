<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sand Box 3D for PC</title>
    
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script> 
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <style>
        /* --- GLOBAL SETUP --- */
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            outline: none;
            cursor: default;
        }

        /* --- UI PANELS --- */
        .ui-panel-base {
            position: absolute;
            width: 250px;
            background: rgba(30, 30, 30, 0.95);
            border-radius: 8px;
            padding: 10px 15px 15px 15px;
            color: #eee;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid #444;
            pointer-events: auto;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 20;
            transition: transform 0.2s ease-in-out, opacity 0.2s;
        }

        /* Scrollbar styling for panels */
        .ui-panel-base::-webkit-scrollbar { width: 6px; }
        .ui-panel-base::-webkit-scrollbar-track { background: #222; }
        .ui-panel-base::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

        #left-panel { top: 20px; left: 20px; }
        #right-panel { top: 20px; right: 20px; }

        /* --- MINIMIZED/HIDDEN STATE --- */
        /* We hide the content or the whole panel based on logic */
        .ui-panel-base.hidden {
            display: none;
        }
        
        .ui-panel-base.minimized {
            width: 140px; 
            height: 35px; 
            overflow: hidden; 
            padding: 0 10px;
            display: flex;
            align-items: center;
        }
        .ui-panel-base.minimized .panel-content { display: none; }
        .ui-panel-base.minimized .panel-header {
            border-bottom: none; 
            margin-bottom: 0; 
            padding-bottom: 0;
            width: 100%;
        }
        .ui-panel-base.minimized h2 { font-size: 13px; }

        /* --- COMPONENTS --- */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        h2 { margin: 0; font-size: 18px; color: #4aa3df; }
        
        .section-label {
            font-size: 11px;
            font-weight: bold;
            color: #888;
            margin-top: 15px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .instruction {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.4;
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #4aa3df;
        }
        .control-group { display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px; }

        .slider-group {
            background: #252525;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            margin-bottom: 10px;
        }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; color: #ddd; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; }
        input[type=color] { width: 100%; height: 30px; border: none; padding: 0; background: none; cursor: pointer; }

        /* --- BUTTONS --- */
        button {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            text-align: left;
            display: flex;
            align-items: center;
            font-size: 13px;
            width: 100%; 
            transition: background 0.1s;
        }
        button:hover { background: #444; border-color: #777; }
        button.active { background: #2a5c80; border-color: #4aa3df; font-weight: bold; }

        .btn-minimize {
            width: 24px; height: 24px; padding: 0;
            display: flex; justify-content: center; align-items: center;
            font-size: 18px; line-height: 1;
            background: transparent; border: 1px solid #555;
        }

        /* --- FLASHBANG OVERLAY --- */
        #flash-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 9999; /* Above everything */
            pointer-events: none; /* Let clicks pass through */
            opacity: 0;
            /* Changed from Flex to Block so the image can stretch freely */
            display: block; 
        }
        
        #flash-meme-vid {
            /* FORCE FULL SCREEN */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            
            /* 'fill' stretches the image to hit every corner (might distort). 
               Change to 'cover' if you want to keep aspect ratio but crop edges. */
            object-fit: fill; 
            
            display: none; /* Hidden during the "White" flash phase */
        }

        /* Flashbang Button Color */
        button#btn-flashbang { border-left: 4px solid #f1c40f; }
        button#btn-flashbang.active { background: #635a2d; border-color: #f1c40f; }
        
        /* Icon for Flashbang */
        .icon-flash { 
            background: #f1c40f; 
            width: 8px; height: 14px; 
            border-radius: 2px; 
            border: 1px solid #fff;
        }

        .icon-throw { 
            background: transparent; 
            width: 10px; height: 10px; 
            border-top: 2px solid #fff; 
            border-right: 2px solid #fff; 
            border-radius: 0 5px 0 0; 
            transform: rotate(-15deg);
        }

        .icon-structure {
            background: transparent;
            width: 10px; height: 10px;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 0 #ccc;
        }

        button#btn-enter-game { background: #27ae60; border-color: #2ecc71; justify-content: center; font-weight: bold; margin-bottom: 5px; }
        button#btn-upload { background: #333; border-color: #888; justify-content: center; font-weight: bold; margin-bottom: 10px; margin-top: 5px; }
        button#btn-upload:hover { background: #555; border-color: #aaa; }

        button#btn-clear { background: #6e2828; border-color: #a34a4a; justify-content: center; font-weight: bold; margin-top: 10px; }

        /* Button Colors */
        button#btn-none, button#btn-none-tools { border-left: 4px solid #aaa; }
        button#btn-push { border-left: 4px solid #2ecc71; }
        button#btn-eraser { border-left: 4px solid #ff5252; }
        button#btn-view { border-left: 4px solid #9b59b6; }
        button#btn-freeze { border-left: 4px solid #3498db; }
        button#btn-build { border-left: 4px solid #e91e63; }
        button#btn-freeze.thaw-mode { border-left-color: #e67e22; }
        button#btn-freeze.thaw-mode.active { background: #a04000; border-color: #e67e22; }
        button#btn-throw { border-left: 4px solid #f39c12; }
        button#btn-throw.active { background: #7e5109; border-color: #f39c12; }
        button#btn-structure { border-left: 4px solid #9b59b6; }
        button#btn-structure.active { background: #4a235a; border-color: #9b59b6; }

        /* Custom Model Button */
        button#btn-custom { border-left: 4px solid #f39c12; }

        /* Explosives */
        button.btn-explosive { border-left: 4px solid #e74c3c; }
        button.btn-explosive.active { background: #802a2a; border-color: #df4a4a; }
        button#btn-frag { border-left: 4px solid #d35400; }

        /* --- ICONS --- */
        .shape-icon { width: 12px; height: 12px; margin-right: 10px; background: #ccc; display: inline-block; }
        .icon-box { border-radius: 2px; }
        .icon-sphere { border-radius: 50%; }
        .icon-cyl { border-radius: 2px; height: 16px; width: 8px; }
        .icon-tri { 
            width: 0; height: 0; background: transparent; 
            border-left: 6px solid transparent; border-right: 6px solid transparent; 
            border-bottom: 12px solid #ccc; 
        }
        .icon-bomb { border-radius: 50%; background: #e74c3c; border: 1px solid #000; }
        .icon-frag { border-radius: 50%; background: #d35400; border: 2px dashed #000; }
        .icon-custom { background: #f39c12; border-radius: 3px; border: 1px solid #fff; }
        
        .icon-hand { background: transparent; border: 1px solid #2ecc71; width: 10px; height: 10px;}
        .icon-cam { background: transparent; border: 2px solid #f1c40f; width: 12px; height: 8px; border-radius: 2px; }
        .icon-eye { background: transparent; border: 2px solid #9b59b6; border-radius: 50%; width: 12px; height: 6px; margin-top: 3px; position: relative; }
        .icon-eye::after { content:''; position: absolute; left: 3px; top: 0; width: 4px; height: 4px; background: #9b59b6; border-radius: 50%; }
        .icon-ice { background: #3498db; transform: rotate(45deg); width: 8px; height: 8px; }
        .icon-glue { background: #e91e63; width: 10px; height: 4px; border-radius: 1px; }
        .icon-eraser { background: white; transform: rotate(45deg); width: 10px; height: 6px; border: 1px solid #aaa; }
        .icon-x { background: transparent; color: #aaa; font-weight: bold; font-size: 14px; line-height: 10px; width: auto; height: auto; }
        .icon-play { background: transparent; border-left: 10px solid white; border-top: 6px solid transparent; border-bottom: 6px solid transparent; width: 0; height: 0; margin-right: 5px; }
        .icon-upload { background: transparent; width: 12px; height: 12px; border-bottom: 2px solid #ccc; position: relative; }
        .icon-upload::after { content:''; position: absolute; left: 3px; top: -2px; width: 0; height: 0; border-left: 3px solid transparent; border-right: 3px solid transparent; border-bottom: 6px solid #ccc; }

        /* Crosshair for FPS mode */
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 0 2px black;
            opacity: 0; /* Hidden by default until locked */
            transition: opacity 0.2s;
        }

    </style>
</head>
<body>

    <input type="file" id="file-input" accept=".glb,.gltf,.obj" style="display: none;" onchange="handleFileUpload(this)">
    
    <div id="flash-layer">
        <video id="flash-meme-vid" playsinline preload="auto"
            style="width:100%; height:100%; object-fit:fill; display:none;">
            <source src="./asset/gahdayum.mp4" type="video/mp4">
        </video>
    </div>

    <audio id="explosion-snd" preload="auto">
        <source src="./asset/bomboclat.mp3" type="audio/mpeg">
    </audio>

    <div id="crosshair"></div>

    <div id="left-panel" class="ui-panel-base minimized">
        <div class="panel-header">
            <h2>Tools [Q]</h2>
            <button class="btn-minimize" id="btn-min-left" onclick="toggleLeftUI()" title="Toggle Menu">+</button>
        </div>

        <div class="panel-content">
            <button id="btn-enter-game" onclick="enterGame()">
                <span class="shape-icon icon-play"></span> FULLSCREEN
            </button>

            <button id="btn-graphics-toggle" onclick="toggleGraphicsUI()"
                style="border-left: 4px solid #4aa3df; margin-bottom: 10px;">
                <span class="shape-icon"
                    style="background: transparent; border: 2px solid #4aa3df; border-radius: 2px; width: 10px; height: 10px;"></span>
                Game Settings
            </button>
            
            <div id="graphics-sub-panel"
                style="display: none; background: rgba(20, 20, 20, 0.5); padding: 10px; border-radius: 4px; margin-bottom: 10px; border: 1px solid #444;">
                <div class="section-label" style="margin-top:0;">Optimization</div>
                <div class="control-group" style="flex-direction: row; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;">
                    <div style="display: flex; width: 100%; gap: 4px; margin-top: 5px;">
                        <button class="fps-btn" onclick="setFPS(24)">24</button>
                        <button class="fps-btn" onclick="setFPS(30)">30</button>
                        <button class="fps-btn" onclick="setFPS(45)">45</button>
                        <button class="fps-btn" onclick="setFPS(60)">60</button>
                        <button class="fps-btn active" id="fps-unlimited" onclick="setFPS(0)">∞</button>
                    </div>
                </div>
                <div class="slider-group">
                    <div class="slider-label"><span>View Distance</span><span id="val-view">500m</span></div>
                    <input type="range" id="opt-view" min="50" max="1500" value="500" step="50" oninput="updateGameSettings()">
                </div>
                <div class="slider-group">
                    <div class="slider-label"><span>FOV (Camera)</span><span id="val-fov">1.2</span></div>
                    <input type="range" id="opt-fov" min="0.5" max="2.5" value="1.2" step="0.1" oninput="updateGameSettings()">
                </div>
            </div>

            <button id="btn-upload" onclick="triggerUpload()">
                <span class="shape-icon icon-upload"></span> Upload 3D Model
            </button>
            
            <div class="instruction">
                <span id="txt-instruct">
                    <b>WASD</b>: Fly &nbsp;|&nbsp; <b>L-SHIFT</b>: Toggle Mouse<br>
                    <b>Q</b>: Tools Panel &nbsp;|&nbsp; <b>E</b>: Objects Panel<br>
                    <b>Click</b>: Use Tool
                </span>
            </div>

            <div class="section-label">Actions</div>
            <div class="control-group">
                <button id="btn-none-tools" onclick="selectShape('none')">
                    <span class="shape-icon icon-x">X</span> None (Safe Mode)
                </button>

                <button id="btn-view" onclick="toggleViewMode()">
                    <span class="shape-icon icon-eye"></span> Possess Object
                </button>
                <button id="btn-throw" onclick="selectShape('throw')">
                    <span class="shape-icon icon-throw"></span> Throw Object
                </button>
                
                <div id="throw-settings" class="slider-group" style="display: none; margin-top: 5px; border-left: 3px solid #f39c12;">
                    <div class="slider-label">
                        <span>Throw Power</span>
                        <span id="throw-display">50</span>
                    </div>
                    <input type="range" id="throw-slider" min="10" max="200" step="5" value="50" oninput="updateThrowForce(this.value)">
                </div>
                <button id="btn-push" onclick="selectShape('push')">
                    <span class="shape-icon icon-hand"></span> Force Push
                </button>
                <button id="btn-eraser" onclick="selectShape('eraser')">
                    <span class="shape-icon icon-eraser"></span> Eraser
                </button>
                <button id="btn-freeze" onclick="toggleFreezeLogic()">
                    <span class="shape-icon icon-ice"></span> Freeze
                </button>
                <button id="btn-build" onclick="toggleBuildMode()">
                    <span class="shape-icon icon-glue"></span> Build Mode
                </button>
            </div>
            
            <button id="btn-clear" onclick="clearObjects()">CLEAR ALL</button>
        </div>
    </div>

    <div id="right-panel" class="ui-panel-base minimized">
        <div class="panel-header">
            <h2>Objects [E]</h2>
            <button class="btn-minimize" id="btn-min-right" onclick="toggleRightUI()" title="Toggle Menu">+</button>
        </div>

        <div class="panel-content">
            
            <div class="section-label">Selection</div>
            <div class="control-group">
                 <button id="btn-none" onclick="selectShape('none')">
                    <span class="shape-icon icon-x">X</span> None (Safe Mode)
                </button>
            </div>

            <div class="section-label">Properties</div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Size</span>
                    <span id="size-display">1.0</span>
                </div>
                <input type="range" id="size-slider" min="0.2" max="5.0" step="0.1" value="1.0" oninput="updateSize(this.value)">
            </div>
            
            <div class="slider-group">
                <div class="slider-label">
                    <span>Mass</span>
                    <span id="mass-display">1.5</span>
                </div>
                <input type="range" id="mass-slider" min="0.1" max="100.0" step="0.1" value="1.5" oninput="updateMass(this.value)">
            </div>
            <div id="structure-settings" class="slider-group" style="display: none; border-left: 3px solid #9b59b6;">
                <div class="slider-label"><span>Grid Size (L x H x W)</span></div>
                <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                    <input type="number" id="struct-x" value="5" min="1" max="20"
                        style="width: 30%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px;">
                    <input type="number" id="struct-y" value="5" min="1" max="20"
                        style="width: 30%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px;">
                    <input type="number" id="struct-z" value="1" min="1" max="20"
                        style="width: 30%; background: #333; color: white; border: 1px solid #555; padding: 4px; border-radius: 4px;">
                </div>
            
                <div class="slider-label"><span>Block Type</span></div>
                <select id="struct-shape"
                    style="width: 100%; background: #333; color: white; border: 1px solid #555; padding: 5px; border-radius: 4px;">
                    <option value="box">Cube</option>
                    <option value="sphere">Sphere</option>
                    <option value="cylinder">Cylinder</option>
                    <option value="triangle">Triangle</option>
                </select>
            </div>

            <div class="slider-group">
                <div class="slider-label"><span>Color</span></div>
                <input type="color" id="color-picker" value="#3498db">
            </div>

            <div id="custom-model-container" style="display: none;">
                <div class="section-label">Custom</div>
                <div class="control-group">
                    <button id="btn-custom" onclick="selectShape('custom')">
                        <span class="shape-icon icon-custom"></span> <span id="custom-name">Spawn Upload</span>
                    </button>
                </div>
            </div>

            <div class="section-label">Shapes</div>
            <div class="control-group">
                <button id="btn-box" class="active" onclick="selectShape('box')">
                    <span class="shape-icon icon-box"></span> Cube
                </button>
                <button id="btn-sphere" onclick="selectShape('sphere')">
                    <span class="shape-icon icon-sphere"></span> Sphere
                </button>
                <button id="btn-cyl" onclick="selectShape('cylinder')">
                    <span class="shape-icon icon-cyl"></span> Cylinder
                </button>
                <button id="btn-tri" onclick="selectShape('triangle')">
                    <span class="shape-icon icon-tri"></span> Triangle
                </button>
                <button id="btn-structure" onclick="selectShape('structure')">
                    <span class="shape-icon icon-structure"></span> Structure
                </button>
            </div>

            <div class="section-label">Explosives</div>
            <div class="control-group">
                <button id="btn-bomb" class="btn-explosive" onclick="selectShape('bomb')">
                    <span class="shape-icon icon-bomb"></span> Bomb
                </button>
                <button id="btn-frag" class="btn-explosive" onclick="selectShape('frag_bomb')">
                    <span class="shape-icon icon-frag"></span> Cluster Bomb
                </button>
                <button id="btn-flashbang" onclick="selectShape('flashbang')">
                    <span class="shape-icon icon-flash"></span> Flashbang
                </button>
            </div>

        </div>
    </div>

    <canvas id="renderCanvas"></canvas>

    <script>
        // ==========================================
        // SECTION 1: UI & INTERACTION LOGIC
        // ==========================================
        
        let selectedShape = 'box'; 
        let freezeAction = 'freeze'; 
        let isBuildMode = false; 
        let currentSize = 1.0;
        let currentMass = 1.5; 
        let spawnedMeshes = [];    
        let sceneRef = null;
        let viewTargetMesh = null;
        let throwForce = 50; 
        
        let customModelTemplate = null; 

        // Movement State
        const moveState = { up: false, down: false, left: false, right: false };
        const lookState = { up: false, down: false, left: false, right: false }; // Kept for Arrows backup

        // --- PC KEYBOARD CONTROLS ---
        window.addEventListener('keydown', (e) => {
            const k = e.code;
            
            // Movement
            if(k === 'KeyW') moveState.up = true;
            if(k === 'KeyS') moveState.down = true;
            if(k === 'KeyA') moveState.left = true;
            if(k === 'KeyD') moveState.right = true;
            
            // Look (Backup)
            if(k === "ArrowUp") lookState.up = true;
            if(k === "ArrowDown") lookState.down = true;
            if(k === "ArrowLeft") lookState.left = true;
            if(k === "ArrowRight") lookState.right = true;

            // Panel Toggles
            if (k === 'KeyQ') toggleLeftUI();
            if (k === 'KeyE') toggleRightUI();

            // Cursor Lock Switch
            if (k === 'ShiftLeft') toggleCursorLock();
        });

        window.addEventListener('keyup', (e) => {
            const k = e.code;
            if(k === 'KeyW') moveState.up = false;
            if(k === 'KeyS') moveState.down = false;
            if(k === 'KeyA') moveState.left = false;
            if(k === 'KeyD') moveState.right = false;
            if(k === "ArrowUp") lookState.up = false;
            if(k === "ArrowDown") lookState.down = false;
            if(k === "ArrowLeft") lookState.left = false;
            if(k === "ArrowRight") lookState.right = false;
        });

        // --- CURSOR LOCK LOGIC ---
        function toggleCursorLock() {
            const canvas = document.getElementById("renderCanvas");
            if (document.pointerLockElement === canvas) {
                document.exitPointerLock();
            } else {
                canvas.requestPointerLock();
            }
        }

        function updateThrowForce(val) {
            throwForce = parseFloat(val);
            document.getElementById('throw-display').innerText = throwForce;
        }

        // Handle Pointer Lock State Change to update UI
        document.addEventListener('pointerlockchange', () => {
            const crosshair = document.getElementById('crosshair');
            const canvas = document.getElementById("renderCanvas");
            
            if (document.pointerLockElement === canvas) {
                // LOCKED
                crosshair.style.opacity = '1';
                document.getElementById('txt-instruct').style.color = "#4aa3df";
            } else {
                // UNLOCKED
                crosshair.style.opacity = '0';
                document.getElementById('txt-instruct').style.color = "#aaa";
            }
        });

        function enterGame() {
            const de = document.documentElement;
            if (de.requestFullscreen) de.requestFullscreen();
            else if (de.webkitRequestFullscreen) de.webkitRequestFullscreen();
        }

        function triggerUpload() {
            document.getElementById('file-input').click();
        }

        function handleFileUpload(input) {
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const blobUrl = URL.createObjectURL(file);
                const ext = file.name.split('.').pop().toLowerCase();
                
                if(sceneRef) {
                    document.getElementById('custom-name').innerText = file.name.length > 15 ? file.name.substring(0,12) + "..." : file.name;

                    BABYLON.SceneLoader.ImportMesh("", "", blobUrl, sceneRef, 
                        function (meshes, particleSystems, skeletons) {
                            if(meshes.length === 0) return;

                            let min = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                            let max = new BABYLON.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

                            meshes.forEach(m => {
                                m.setParent(null); 
                                const b = m.getHierarchyBoundingVectors();
                                min = BABYLON.Vector3.Minimize(min, b.min);
                                max = BABYLON.Vector3.Maximize(max, b.max);
                            });

                            const width = max.x - min.x;
                            const height = max.y - min.y;
                            const depth = max.z - min.z;
                            const center = min.add(max).scale(0.5);

                            const hitBox = BABYLON.MeshBuilder.CreateBox("customHitbox", {width: width, height: height, depth: depth}, sceneRef);
                            hitBox.isVisible = false; 
                            
                            meshes.forEach(m => {
                                m.parent = hitBox;
                                m.position = m.position.subtract(center);
                            });

                            hitBox.setEnabled(false);
                            
                            if (customModelTemplate && customModelTemplate.mesh) {
                                customModelTemplate.mesh.dispose();
                            }

                            customModelTemplate = {
                                mesh: hitBox,
                                dimensions: { width, height, depth }
                            };

                            document.getElementById('custom-model-container').style.display = 'block';
                            selectShape('custom');
                            
                            // Open objects panel if hidden
                            const right = document.getElementById('right-panel');
                            if(right.classList.contains('minimized')) toggleRightUI();

                            input.value = "";
                        }, 
                        null, 
                        function (scene, message, exception) {
                            console.error("Error loading file:", message);
                            alert("Failed to load model.");
                        },
                        "." + ext
                    );
                }
            }
        }

        function toggleLeftUI() {
            const left = document.getElementById('left-panel');
            const leftBtn = document.getElementById('btn-min-left');
            const isMinimizing = !left.classList.contains('minimized');
            
            if (isMinimizing) {
                left.classList.add('minimized');
                leftBtn.innerText = "+";
            } else {
                left.classList.remove('minimized');
                leftBtn.innerText = "-";
            }
        }

        function toggleGraphicsUI() {
                const subPanel = document.getElementById('graphics-sub-panel');
                const btn = document.getElementById('btn-graphics-toggle');
                const isHidden = subPanel.style.display === 'none';

                subPanel.style.display = isHidden ? 'block' : 'none';
                btn.classList.toggle('active', isHidden);
            }

            function updateGraphics() {
                // 1. Get Values from UI
                const resScale = document.getElementById('opt-res').value;
                const viewDist = document.getElementById('opt-view').value;

                // 2. Update UI Labels
                document.getElementById('val-res').innerText = resScale + "%";
                document.getElementById('val-view').innerText = viewDist + "m";

                // 3. Apply to Engine (Shaman Logic)
                const sb3d = workshop.shaman.sandbox3d;
                if (sb3d.engine && sb3d.cameraFree) {
                    // Apply Resolution Scaling
                    sb3d.engine.setHardwareScalingLevel(1 / (resScale / 100));

                    // Apply View Distance (Far Clip Plane)
                    sb3d.cameraFree.maxZ = parseFloat(viewDist);
                }
            }

        function toggleRightUI() {
            const right = document.getElementById('right-panel');
            const rightBtn = document.getElementById('btn-min-right');
            const isMinimizing = !right.classList.contains('minimized');

            if (isMinimizing) {
                right.classList.add('minimized');
                rightBtn.innerText = "+";
            } else {
                right.classList.remove('minimized');
                rightBtn.innerText = "-";
            }
        }

        function toggleBuildMode() {
            if(selectedShape === 'none' || selectedShape === 'eraser' || selectedShape === 'push' || selectedShape === 'view') {
                selectShape('box');
                isBuildMode = true; 
            } else {
                isBuildMode = !isBuildMode; 
            }

            const btn = document.getElementById('btn-build');
            if(isBuildMode) btn.classList.add('active');
            else btn.classList.remove('active');
        }

        function selectShape(shape) {
            selectedShape = shape;
            const instruct = document.getElementById('txt-instruct');
            const throwSettings = document.getElementById('throw-settings');
            const structSettings = document.getElementById('structure-settings');
            
            document.querySelectorAll('button').forEach(b => {
                if(!b.classList.contains('btn-minimize') && b.id !== 'btn-enter-game' && b.id !== 'btn-build' && b.id !== 'btn-upload') {
                    b.classList.remove('active');
                }
            });

            if (shape === 'none') {
                isBuildMode = false;
                document.getElementById('btn-build').classList.remove('active');
            }

            if (shape === 'throw') {
                throwSettings.style.display = 'block';
            } else {
                throwSettings.style.display = 'none';
            }

            if (shape === 'structure') {
                structSettings.style.display = 'block';
                instruct.innerHTML = "<b>Click</b>: Spawn Structure<br>Adjust L/H/W in Objects Panel.";
            } else {
                structSettings.style.display = 'none';
            }

            if (shape === 'view') {
                workshop.shaman.sandbox3d.resetCameraTarget();
            }
            else {
                viewTargetMesh = null;
            }

            let btnId = 'btn-' + shape;
            if (shape === 'cylinder') btnId = 'btn-cyl';
            if (shape === 'triangle') btnId = 'btn-tri';
            if (shape === 'frag_bomb') btnId = 'btn-frag';
            if (shape === 'flashbang') btnId = 'btn-flashbang';
            
            const activeBtn = document.getElementById(btnId);
            if(activeBtn) activeBtn.classList.add('active');

            if (shape === 'none') {
                 const btnTools = document.getElementById('btn-none-tools');
                 if(btnTools) btnTools.classList.add('active');
                 const btnRight = document.getElementById('btn-none');
                 if(btnRight) btnRight.classList.add('active');
            }

            if(shape === 'freeze' && freezeAction === 'thaw') {
                document.getElementById('btn-freeze').classList.add('thaw-mode');
            }
        }

            let targetFPS = 0; // 0 represents Unlimited/Native
            let lastFrameTime = performance.now();

            function setFPS(val) {
                targetFPS = val;

                    // UI Feedback
                document.querySelectorAll('.fps-btn').forEach(btn => {
                     btn.classList.remove('active');
                     if ((val === 0 && btn.innerText === '∞') || btn.innerText == val) {
                         btn.classList.add('active');
                     }
                });
            }
            

            function updateGameSettings() {
                // 1. Get Values
                const viewDist = document.getElementById('opt-view').value;
                const fovVal = document.getElementById('opt-fov').value;

                // 2. Update UI Labels
                document.getElementById('val-view').innerText = viewDist + "m";
                document.getElementById('val-fov').innerText = fovVal;

                // 3. Apply to Engine
                const sb3d = workshop.shaman.sandbox3d;
                if (sb3d.cameraFree) {
                    sb3d.cameraFree.maxZ = parseFloat(viewDist);
                    sb3d.cameraFree.fov = parseFloat(fovVal);
                }
            }

        function updateSize(val) {
            currentSize = parseFloat(val);
            document.getElementById('size-display').innerText = currentSize.toFixed(1);

            // AUTO-CALCULATE MASS based on Size (using your standard 1.5 multiplier)
            // This ensures big things get heavier automatically...
            currentMass = (currentSize * 1.5);

            // ...unless you manually change the mass slider afterwards.
            const massSlider = document.getElementById('mass-slider');
            const massDisplay = document.getElementById('mass-display');

            massSlider.value = currentMass;
            massDisplay.innerText = currentMass.toFixed(1);
        }

        function updateMass(val) {
            // Manual override for Mass
            currentMass = parseFloat(val);
            document.getElementById('mass-display').innerText = currentMass.toFixed(1);
        }

        function toggleFreezeLogic() {
            const btn = document.getElementById('btn-freeze');
            if(selectedShape === 'freeze') {
                if(freezeAction === 'freeze') {
                    freezeAction = 'thaw';
                    btn.innerHTML = '<span class="shape-icon icon-ice" style="background:#e67e22"></span> Unfreeze';
                    btn.classList.add('thaw-mode');
                } else {
                    freezeAction = 'freeze';
                    btn.innerHTML = '<span class="shape-icon icon-ice"></span> Freeze';
                    btn.classList.remove('thaw-mode');
                }
            } else {
                selectShape('freeze');
            }
        }

        function toggleViewMode() {
            if(selectedShape === 'view') {
                viewTargetMesh = null;
                selectShape('box'); 
            } else {
                selectShape('view');
            }
        }

        function clearObjects() {
            if (!sceneRef) return;
            if(selectedShape === 'view') toggleViewMode();
            viewTargetMesh = null;
            spawnedMeshes.forEach(mesh => { if(mesh && !mesh.isDisposed()) mesh.dispose(); });
            spawnedMeshes = [];
        }

        // ==========================================
        // SECTION 2: BABYLON 3D ENGINE
        // ==========================================

        const workshop = {
            shaman: {
                sandbox3d: {
                    canvas: document.getElementById("renderCanvas"),
                    engine: null,
                    scene: null,
                    cameraFree: null,

                    init: function() {
                        this.engine = new BABYLON.Engine(this.canvas, true);
                        this.scene = this.createScene();
                        sceneRef = this.scene;

                        this.engine.runRenderLoop(() => {
                            const now = performance.now();

                            // If Unlimited, skip the math and just render
                            if (targetFPS === 0) {
                                this.handleKillZone();
                                this.handleInput();
                                this.scene.render();
                                return;
                            }

                            // Otherwise, apply the Shaman's throttle
                            const delta = now - lastFrameTime;
                            const interval = 1000 / targetFPS;

                            if (delta >= interval) {
                                lastFrameTime = now - (delta % interval);
                                this.handleKillZone();
                                this.handleInput();
                                this.scene.render();
                            }
                        });
                        window.addEventListener("resize", () => { this.engine.resize(); });
                    },

                    createScene: function() {
                        const scene = new BABYLON.Scene(this.engine);
                        // Standard gravity
                        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());

                        this.cameraFree = new BABYLON.UniversalCamera("CameraFree", new BABYLON.Vector3(0, 20, -40), scene);
                        this.cameraFree.setTarget(BABYLON.Vector3.Zero());
                        this.cameraFree.fov = 1.2;
                         
                        // Detach default key controls to prevent conflicts
                        this.cameraFree.keysUp = [];
                        this.cameraFree.keysDown = [];
                        this.cameraFree.keysLeft = [];
                        this.cameraFree.keysRight = [];
                        
                        // We do NOT attach default controls because we are handling rotation manually via PointerLock
                        // this.cameraFree.attachControl(this.canvas, true);
                        
                        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                        light.intensity = 1.2;
                        const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
                        dirLight.intensity = 0.8;

                        const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 500, height: 500}, scene);
                        const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
                        groundMat.diffuseColor = new BABYLON.Color3(0.15, 0.15, 0.2);
                        groundMat.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                        ground.material = groundMat;
                        ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.5, friction: 0.5 }, scene);

                        const ramp = BABYLON.MeshBuilder.CreateBox("ramp", {width: 15, height: 1, depth: 30}, scene);
                        ramp.position = new BABYLON.Vector3(30, 1, 0); 
                        ramp.rotation.z = Math.PI / 8;
                        const rampMat = new BABYLON.StandardMaterial("rampMat", scene);
                        rampMat.diffuseColor = new BABYLON.Color3(0.25, 0.25, 0.3);
                        ramp.material = rampMat;
                        ramp.physicsImpostor = new BABYLON.PhysicsImpostor(ramp, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.2, friction: 0.4 }, scene);

                        this.createPillars(scene);
                        this.setupInteraction(scene);
                        return scene;
                    },

                    resetCameraTarget: function() { },

                    handleKillZone: function() {
                        const killY = -100;
                        for(let i = spawnedMeshes.length - 1; i >= 0; i--) {
                            const mesh = spawnedMeshes[i];
                            if(mesh && !mesh.isDisposed()) {
                                if(mesh.position.y < killY) {
                                    if(mesh === viewTargetMesh) toggleViewMode();
                                    mesh.dispose();
                                    spawnedMeshes.splice(i, 1);
                                }
                            }
                        }
                    },

                    handleInput: function() {
                        if(!this.cameraFree) return;
                        
                        const cam = this.cameraFree;
                        const moveSpeed = 0.5;
                        const lookSpeed = 0.03;

                        if(lookState.left) cam.rotation.y -= lookSpeed;
                        if(lookState.right) cam.rotation.y += lookSpeed;
                        if(lookState.up) cam.rotation.x -= lookSpeed;
                        if(lookState.down) cam.rotation.x += lookSpeed;

                        if (selectedShape === 'view' && viewTargetMesh && viewTargetMesh.physicsImpostor) {
                            cam.position.copyFrom(viewTargetMesh.position);
                            cam.position.y += (3.0 * (currentSize || 1)); 

                            const forcePower = 0.5 * (viewTargetMesh.physicsImpostor.mass); 
                            const impulse = BABYLON.Vector3.Zero();
                            const forward = cam.getDirection(BABYLON.Vector3.Forward());
                            const right = cam.getDirection(BABYLON.Vector3.Right());
                            forward.y = 0; forward.normalize();
                            right.y = 0; right.normalize();

                            if(moveState.up) impulse.addInPlace(forward.scale(forcePower));
                            if(moveState.down) impulse.addInPlace(forward.scale(-forcePower));
                            if(moveState.left) impulse.addInPlace(right.scale(-forcePower));
                            if(moveState.right) impulse.addInPlace(right.scale(forcePower));

                            if(!impulse.equals(BABYLON.Vector3.Zero())) {
                                viewTargetMesh.physicsImpostor.applyImpulse(impulse, viewTargetMesh.getAbsolutePosition());
                            }
                        } else {
                            if(moveState.up) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Forward()).scale(moveSpeed));
                            if(moveState.down) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Backward()).scale(moveSpeed));
                            if(moveState.left) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Left()).scale(moveSpeed));
                            if(moveState.right) cam.position.addInPlace(cam.getDirection(BABYLON.Vector3.Right()).scale(moveSpeed));
                        }
                    },

                    createPillars: function(scene) {
                        const mat = new BABYLON.StandardMaterial("pillarMat", scene);
                        mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);

                        for (let i = 0; i < 25; i++) {
                            const pillar = BABYLON.MeshBuilder.CreateBox("pillar", { width: 4, height: 15, depth: 4 }, scene);

                            // Distribution math for 500x500 map:
                            // (Math.random() * TotalSize) - (HalfSize)
                            let posX = Math.random() * 500 - 250;
                            let posZ = Math.random() * 500 - 250;

                            pillar.position = new BABYLON.Vector3(posX, 7.5, posZ);

                            const pMat = new BABYLON.StandardMaterial("pMat", scene);
                            pMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                            pillar.material = pMat;

                            pillar.physicsImpostor = new BABYLON.PhysicsImpostor(pillar, BABYLON.PhysicsImpostor.BoxImpostor, {
                                mass: 0,
                                restitution: 0.1,
                                friction: 0.5
                            }, scene);
                        }
                    },

                    setupInteraction: function (scene) {
                        document.addEventListener("mousemove", (event) => {
                            if (document.pointerLockElement === this.canvas) {
                                if (this.cameraFree) {
                                    const sensitivity = 0.002;
                                    this.cameraFree.rotation.y += event.movementX * sensitivity;
                                    this.cameraFree.rotation.x += event.movementY * sensitivity;
                                }
                            }
                        });

                        // Unified Click Interaction
                        scene.onPointerObservable.add((pointerInfo) => {
                            if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                                if (pointerInfo.event.button !== 0) return; // Only Left Click

                                // --- THROW MODE LOGIC ---
                                // We check this BEFORE looking for a hit, so you can throw into the sky.
                                if (selectedShape === 'throw') {
                                    const cam = this.cameraFree;
                                    const forward = cam.getDirection(BABYLON.Vector3.Forward());

                                    // 1. Create Projectile (Snowball/Sphere)
                                    // Spawns slightly in front of camera to avoid clipping
                                    const projectile = BABYLON.MeshBuilder.CreateSphere("projectile", { diameter: 0.5 }, scene);
                                    projectile.position = cam.position.add(forward.scale(1.5));

                                    // 2. Color it (White/Snowball style)
                                    const pMat = new BABYLON.StandardMaterial("pMat", scene);
                                    pMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 1.0);
                                    projectile.material = pMat;

                                    // 3. Add Physics
                                    projectile.physicsImpostor = new BABYLON.PhysicsImpostor(
                                        projectile,
                                        BABYLON.PhysicsImpostor.SphereImpostor,
                                        { mass: 1, restitution: 0.5, friction: 0.5 },
                                        scene
                                    );

                                    // 4. YEET (Apply Force)
                                    // We multiply by mass to ensure consistent speed regardless of size updates later
                                    projectile.physicsImpostor.applyImpulse(
                                        forward.scale(throwForce),
                                        projectile.getAbsolutePosition()
                                    );

                                    // Add to array so it gets cleaned up by the KillZone
                                    spawnedMeshes.push(projectile);
                                    return; // Stop processing other clicks
                                }

                                if (selectedShape === 'none') return;

                                let pickInfo;

                                if (document.pointerLockElement === this.canvas) {
                                    const ray = scene.createPickingRay(
                                        this.canvas.width / 2,
                                        this.canvas.height / 2,
                                        BABYLON.Matrix.Identity(),
                                        this.cameraFree
                                    );
                                    pickInfo = scene.pickWithRay(ray);
                                } else {
                                    pickInfo = scene.pick(scene.pointerX, scene.pointerY);
                                }

                                if (pickInfo && pickInfo.hit && pickInfo.pickedMesh) {
                                    let mesh = pickInfo.pickedMesh;
                                    if (mesh.parent && (mesh.parent.name.includes("customHitbox") || mesh.parent.name.includes("customInstance"))) {
                                        mesh = mesh.parent;
                                    }

                                    if (selectedShape === 'view') {
                                        if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                            viewTargetMesh = mesh;
                                        }
                                        return;
                                    }

                                    if (selectedShape === 'eraser') {
                                        if (mesh.name === "ground" || mesh.name === "ramp") return;
                                        mesh.dispose();
                                        const index = spawnedMeshes.indexOf(mesh);
                                        if (index > -1) spawnedMeshes.splice(index, 1);
                                        return;
                                    }

                                    if (selectedShape === 'freeze') {
                                        this.handleFreeze(mesh);
                                        return;
                                    }

                                    if (selectedShape === 'structure') {
                                        this.spawnStructure(pickInfo, scene);
                                        return;
                                    }

                                    if (selectedShape === 'push') {
                                        if (mesh.physicsImpostor && mesh.physicsImpostor.mass > 0) {
                                            const ray = pickInfo.ray;
                                            const forceDirection = ray.direction;
                                            const forceMagnitude = 50 * (mesh.scaling.x);
                                            mesh.physicsImpostor.applyImpulse(forceDirection.scale(forceMagnitude), pickInfo.pickedPoint);
                                        }
                                        return;
                                    }

                                    this.spawnObject(selectedShape, pickInfo, scene);
                                }
                            }
                        });

                        window.addEventListener("contextmenu", e => e.preventDefault());
                    },

                    handleFreeze: function (mesh) {
                        if (!mesh.physicsImpostor || mesh.name === "ground" || mesh.name === "ramp") return;
                        if (freezeAction === 'freeze') {
                            if (!mesh.metadata) mesh.metadata = {};
                            if (mesh.physicsImpostor.mass > 0) {
                                mesh.metadata.originalMass = mesh.physicsImpostor.mass;
                                mesh.physicsImpostor.setMass(0);
                                mesh.physicsImpostor.sleep();
                                if (mesh.material) {
                                    mesh.metadata.originalColor = mesh.material.diffuseColor ? mesh.material.diffuseColor.clone() : null;
                                    if (mesh.material.emissiveColor) mesh.material.emissiveColor = new BABYLON.Color3(0.2, 0.6, 1);
                                }
                            }
                        } else {
                            if (mesh.metadata && mesh.metadata.originalMass !== undefined) {
                                mesh.physicsImpostor.setMass(mesh.metadata.originalMass);
                                mesh.physicsImpostor.wakeUp();
                                if (mesh.material && mesh.metadata.originalColor) {
                                    if (mesh.material.diffuseColor) mesh.material.diffuseColor = mesh.metadata.originalColor;
                                    if (mesh.material.emissiveColor) mesh.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                                }
                                mesh.metadata = null;
                            }
                        }
                    },

                    spawnObject: function(type, pickInfo, scene) {
                        const normal = pickInfo.getNormal(true);
                        if(!normal) return;

                        let mesh;
                        const mat = new BABYLON.StandardMaterial("objMat" + Date.now(), scene);
                        
                        const pickerVal = document.getElementById('color-picker').value;
                        mat.diffuseColor = BABYLON.Color3.FromHexString(pickerVal);
                        
                        const scale = currentSize; 
                        const pivotOffset = scale * 0.5 + (isBuildMode ? 0 : 0.01);
                        const spawnPos = pickInfo.pickedPoint.add(normal.scale(pivotOffset));

                        if (type === 'custom' && customModelTemplate) {
                            mesh = customModelTemplate.mesh.clone("customInstance_" + Date.now());
                            mesh.setEnabled(true);
                            mesh.scaling = new BABYLON.Vector3(scale, scale, scale);
                            const customOffset = (customModelTemplate.dimensions.height * scale) / 2;
                            mesh.position = pickInfo.pickedPoint.add(normal.scale(customOffset));
                        }
                        else if (type === 'box') {
                            mesh = BABYLON.MeshBuilder.CreateBox("box", {size: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                        } 
                        else if (type === 'sphere') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'cylinder') {
                            mesh = BABYLON.MeshBuilder.CreateCylinder("cyl", {height: scale, diameter: scale/2}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'triangle') {
                            mesh = BABYLON.MeshBuilder.CreateCylinder("tri", {height: scale, diameter: scale, tessellation: 3}, scene);
                            mesh.position.copyFrom(spawnPos);
                        }
                        else if (type === 'bomb' || type === 'frag_bomb') {
                            mesh = BABYLON.MeshBuilder.CreateSphere("bomb", {diameter: scale}, scene);
                            mesh.position.copyFrom(spawnPos);
                            mat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1); 
                            mat.emissiveColor = new BABYLON.Color3(0.1, 0, 0); 
                            if (type === 'frag_bomb') mat.emissiveColor = new BABYLON.Color3(0.3, 0.1, 0); 
                        }

                        // --- NEW FLASHBANG MESH ---
                        else if (type === 'flashbang') {
                            // Flashbangs look like canisters (Cylinders)
                            mesh = BABYLON.MeshBuilder.CreateCylinder("flashbang", { height: scale * 1.5, diameter: scale * 0.5 }, scene);
                            mesh.position.copyFrom(spawnPos);
                            // Flashbang color (Yellow/White tip)
                            mat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                            mat.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0);
                        }

                        if (mesh) {
                            if(type !== 'custom') mesh.material = mat; 
                            
                            let massVal = currentMass;
                            
                            if (type === 'custom' && customModelTemplate) {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 5 * scale, restitution: 0.1, friction: 0.5 }, scene);
                            }
                            else if (type === 'box') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: massVal, restitution: 0.1, friction: 0.8 }, scene);
                            } else if (type === 'sphere' || type.includes('bomb')) {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.SphereImpostor, { mass: massVal, restitution: 0.4, friction: 0.5 }, scene);
                            } else if (type === 'cylinder' || type === 'triangle') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: massVal, restitution: 0.1, friction: 0.8 }, scene);
                            }
                            else if (type === 'flashbang') {
                                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: massVal, restitution: 0.3, friction: 0.5 }, scene);
                                this.armBomb(mesh, scene, false, true); // Pass 'true' for isFlash
                            }

                            if (type.includes('bomb')) this.armBomb(mesh, scene, type === 'frag_bomb');
                            
                            if(isBuildMode && pickInfo.pickedMesh && pickInfo.pickedMesh.physicsImpostor && !type.includes('bomb')) {
                                const joint = new BABYLON.PhysicsJoint(BABYLON.PhysicsJoint.LockJoint, {});
                                pickInfo.pickedMesh.physicsImpostor.addJoint(mesh.physicsImpostor, joint);
                                if(mesh.material) mesh.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                            }
                            spawnedMeshes.push(mesh);
                        }
                    },

                    spawnStructure: function (pickInfo, scene) {
                        const normal = pickInfo.getNormal(true);
                        if (!normal) return;

                        // Get Dimensions from Input
                        // We clamp them to avoid crashing the browser with 10000 blocks
                        let dimX = parseInt(document.getElementById('struct-x').value) || 1;
                        let dimY = parseInt(document.getElementById('struct-y').value) || 1;
                        let dimZ = parseInt(document.getElementById('struct-z').value) || 1;

                        // Hard Cap for safety (Max 10x10x10)
                        if (dimX > 10) dimX = 10;
                        if (dimY > 10) dimY = 10;
                        if (dimZ > 10) dimZ = 10;

                        const shapeType = document.getElementById('struct-shape').value;
                        const scale = currentSize;

                        // Calculate Start Position (Offset so it builds UP and OUT from the click)
                        // We add a tiny gap (scale * 1.02) to prevent immediate physics explosion
                        const gap = scale * 1.02;
                        const startPos = pickInfo.pickedPoint.add(normal.scale(scale / 2));

                        for (let x = 0; x < dimX; x++) {
                            for (let y = 0; y < dimY; y++) {
                                for (let z = 0; z < dimZ; z++) {

                                    // Calculate Offset
                                    const offsetX = (x - dimX / 2) * gap; // Center X
                                    const offsetY = y * gap;            // Build Up Y
                                    const offsetZ = (z - dimZ / 2) * gap; // Center Z

                                    const spawnPos = startPos.add(new BABYLON.Vector3(offsetX, offsetY, offsetZ));

                                    // We reuse the logic from spawnObject, but we need to bypass the 'pickInfo' requirement.
                                    // So we simply create the mesh directly here to keep it fast.
                                    this.createSingleBlock(shapeType, spawnPos, scale, scene);
                                }
                            }
                        }
                    },

                    createSingleBlock: function (type, position, scale, scene) {
                        let mesh;
                        const mat = new BABYLON.StandardMaterial("structMat" + Date.now() + Math.random(), scene);
                        const pickerVal = document.getElementById('color-picker').value;
                        mat.diffuseColor = BABYLON.Color3.FromHexString(pickerVal);

                        if (type === 'box') mesh = BABYLON.MeshBuilder.CreateBox("s_box", { size: scale }, scene);
                        else if (type === 'sphere') mesh = BABYLON.MeshBuilder.CreateSphere("s_sphere", { diameter: scale }, scene);
                        else if (type === 'cylinder') mesh = BABYLON.MeshBuilder.CreateCylinder("s_cyl", { height: scale, diameter: scale / 2 }, scene);
                        else if (type === 'triangle') mesh = BABYLON.MeshBuilder.CreateCylinder("s_tri", { height: scale, diameter: scale, tessellation: 3 }, scene);

                        if (mesh) {
                            mesh.position = position;
                            mesh.material = mat;

                            // Physics
                            let impostorType = BABYLON.PhysicsImpostor.BoxImpostor;
                            if (type === 'sphere') impostorType = BABYLON.PhysicsImpostor.SphereImpostor;
                            if (type === 'cylinder' || type === 'triangle') impostorType = BABYLON.PhysicsImpostor.CylinderImpostor;

                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, impostorType, {
                                mass: currentMass,
                                restitution: 0.1,
                                friction: 0.8
                            }, scene);

                            spawnedMeshes.push(mesh);
                        }
                    },

                    armBomb: function (bombMesh, scene, isFragment, isFlash = false) {
                        let flashCount = 0;
                        const flashInterval = setInterval(() => {
                            if (!bombMesh || bombMesh.isDisposed()) { clearInterval(flashInterval); return; }

                            // Visual countdown colors
                            let colorOn = new BABYLON.Color3(1, 0, 0); // Default Red
                            if (isFragment) colorOn = new BABYLON.Color3(1, 0.5, 0); // Orange
                            if (isFlash) colorOn = new BABYLON.Color3(1, 1, 1); // White for Flashbang

                            if (flashCount % 2 === 0) bombMesh.material.emissiveColor = colorOn;
                            else bombMesh.material.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                            flashCount++;
                        }, isFlash ? 200 : 500);

                        setTimeout(() => {
                            clearInterval(flashInterval);
                            if (bombMesh && !bombMesh.isDisposed()) {
                                if (isFlash) this.triggerFlashbang(bombMesh.position, scene);
                                else this.explode(bombMesh.position, scene, isFragment, bombMesh.scaling.x);

                                bombMesh.dispose();
                            }
                        }, isFlash ? 2500 : 4000);
                    },

                    explode: function (center, scene, isFragment, scaleMultiplier, playSound = true) {
                        // Only play sound if playSound is true (default)
                        if (playSound) {
                            const snd = document.getElementById('explosion-snd');
                            if (snd) {
                                snd.currentTime = 0;
                                snd.volume = 1.0;
                                snd.play().catch(e => console.log("Audio blocked: Interaction required."));
                            }
                        }

                        const explosion = BABYLON.MeshBuilder.CreateSphere("explosion", { diameter: 1 * scaleMultiplier }, scene);
                        explosion.position = center;
                        const expMat = new BABYLON.StandardMaterial("expMat", scene);
                        expMat.diffuseColor = isFragment ? new BABYLON.Color3(1, 0.8, 0) : new BABYLON.Color3(1, 0.5, 0);
                        expMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0);
                        expMat.alpha = 0.8;
                        explosion.material = expMat;

                        let scale = 1;
                        const anim = scene.onBeforeRenderObservable.add(() => {
                            scale += 0.8;
                            explosion.scaling = new BABYLON.Vector3(scale, scale, scale);
                            expMat.alpha -= 0.05;
                            if (expMat.alpha <= 0) {
                                scene.onBeforeRenderObservable.remove(anim);
                                explosion.dispose();
                            }
                        });

                        const blastRadius = 25 * scaleMultiplier;
                        const blastForce = 60 * scaleMultiplier;
                        spawnedMeshes.forEach(mesh => {
                            if (mesh && !mesh.isDisposed() && mesh.physicsImpostor) {
                                if (mesh.metadata && mesh.metadata.originalMass) return;
                                const dir = mesh.getAbsolutePosition().subtract(center);
                                const dist = dir.length();
                                if (dist < blastRadius) {
                                    dir.normalize();
                                    const forceMagnitude = blastForce * (1 - dist / blastRadius);
                                    const contactPoint = mesh.getAbsolutePosition();
                                    const impulse = dir.scale(forceMagnitude);
                                    mesh.physicsImpostor.applyImpulse(impulse, contactPoint);
                                }
                            }
                        });

                        if (isFragment) this.spawnFragments(center, scene);
                    },

                    triggerFlashbang: function (center, scene) {
                        // Keep the small physical explosion for physics impact, BUT SILENCE THE BOMBOCLAT (playSound = false)
                        this.explode(center, scene, false, 0.2, false);

                        const layer = document.getElementById('flash-layer');
                        const video = document.getElementById('flash-meme-vid');
                        if (!layer || !video) return;

                        // Reset layer and prepare video immediately
                        layer.style.transition = 'none';
                        layer.style.backgroundColor = 'transparent';
                        layer.style.opacity = '1';

                        video.currentTime = 0;
                        video.muted = false;
                        video.volume = 1.0;
                        video.style.display = 'block';

                        // Immediate Playback of Gahdayum
                        video.play().catch(e => {
                            console.error("Audio/Video blocked! Ensure pointer is locked or screen clicked.", e);
                        });

                        // Start fading out towards the end of the clip
                        setTimeout(() => {
                            layer.style.transition = 'opacity 1.5s ease-out';
                            layer.style.opacity = '0';
                        }, 3700);

                        // Complete cleanup
                        setTimeout(() => {
                            video.pause();
                            video.style.display = 'none';
                        }, 5250);
                    },

                    spawnFragments: function (center, scene) {
                        const numFrags = 20;
                        for (let i = 0; i < numFrags; i++) {
                            const frag = BABYLON.MeshBuilder.CreateBox("frag", { size: 0.5 }, scene);
                            frag.position = center.clone();
                            frag.position.y += (Math.random() - 0.5) * 0.2;
                            frag.position.x += (Math.random() - 0.5) * 0.1;
                            frag.position.z += (Math.random() - 0.5) * 0.1;
                            const fMat = new BABYLON.StandardMaterial("fMat", scene);
                            fMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                            fMat.emissiveColor = new BABYLON.Color3(0.8, 0.3, 0);
                            frag.material = fMat;
                            frag.physicsImpostor = new BABYLON.PhysicsImpostor(frag, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0.5, restitution: 0.1 }, scene);
                            const exDir = new BABYLON.Vector3(
                                Math.random() - 0.5,
                                Math.random() - 0.5, // Allow negative Y for a spherical blast
                                Math.random() - 0.5
                            ).normalize();
                            frag.physicsImpostor.applyImpulse(exDir.scale(12), frag.getAbsolutePosition());
                            spawnedMeshes.push(frag);
                        }
                    }
                }
            }
        };

        workshop.shaman.sandbox3d.init();

    </script>
</body>
</html>