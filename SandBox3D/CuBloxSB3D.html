<!DOCTYPE html>
<html>
<head>
    <title>CuBlox SB3D - Refined</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <style>
        /* --- CSS STYLING (Ported from SandBox3D) --- */
        body, html { 
            margin: 0; padding: 0; 
            overflow: hidden; 
            width: 100%; height: 100%;
            background: #1a1a1a; color: white; 
            font-family: 'Segoe UI', Tahoma, sans-serif; 
            user-select: none;
            -webkit-user-select: none;
        }
        
        #renderCanvas { 
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%; 
            touch-action: none; outline: none; z-index: 0;
        }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* Connection Panel */
        #connection-panel { 
            pointer-events: auto; background: rgba(30,30,30,0.95); padding: 20px; border-radius: 8px; 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            text-align: center; border: 1px solid #4aa3df; z-index: 100; 
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            width: 300px;
        }
        
        input[type="text"], input[type="number"] { 
            padding: 8px; border-radius: 4px; border: 1px solid #555; 
            background: #222; color: white; margin: 5px; outline: none; width: 60%;
        }
        
        .color-row { display: flex; justify-content: center; gap: 10px; margin: 10px 0; align-items: center; }
        input[type="color"] { border: none; width: 40px; height: 40px; cursor: pointer; background: none; padding: 0; }

        .btn-std { 
            padding: 10px 20px; border-radius: 4px; border: none; 
            background: #4aa3df; color: #000; font-weight: bold; 
            cursor: pointer; margin: 10px 5px; transition: 0.1s; width: 40%;
        }
        .btn-std:hover { background: #fff; }
        .btn-std:active { transform: scale(0.98); }

        /* --- SETTINGS PANEL (Matches SB3D Style) --- */
        .ui-panel-base {
            pointer-events: auto; position: absolute; right: 10px; top: 10px;
            width: 250px; background: rgba(30, 30, 30, 0.95);
            border-radius: 8px;
            padding: 10px; color: #eee; border: 1px solid #444;
            max-height: 70vh; overflow-y: auto;
            z-index: 60; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        
        /* Scrollbar */
        .ui-panel-base::-webkit-scrollbar { width: 5px; }
        .ui-panel-base::-webkit-scrollbar-track { background: #333; }
        .ui-panel-base::-webkit-scrollbar-thumb { background: #4aa3df; border-radius: 3px; }

        /* Minimized State (Circle Button) */
        .ui-panel-base.minimized {
            width: 40px; height: 40px; overflow: hidden; padding: 0;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%; border: 2px solid #555;
            background: rgba(30,30,30,0.8);
        }
        .ui-panel-base.minimized .panel-content { display: none; }
        .ui-panel-base.minimized .panel-header { border: none; margin: 0; padding: 0; width: 100%; height: 100%; justify-content: center; }
        .ui-panel-base.minimized h2 { display: none; }
        .ui-panel-base.minimized .btn-minimize { width: 100%; height: 100%; border: none; font-size: 20px; background: transparent; color: #4aa3df; }
        
        .panel-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid #555; padding-bottom: 8px; margin-bottom: 10px;
        }
        .panel-header h2 { margin: 0; font-size: 16px; color: #4aa3df; }

        .btn-minimize {
            background: transparent; border: 1px solid #555; color: white;
            width: 24px; height: 24px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-weight: bold; border-radius: 4px;
        }

        .setting-row { display: flex; justify-content: space-between; align-items: center; font-size: 12px; margin-bottom: 8px; }
        
        /* Toggles */
        .switch { position: relative; display: inline-block; width: 30px; height: 16px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-toggle { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; }
        .slider-toggle:before { position: absolute; content: ""; height: 10px; width: 10px; left: 3px; bottom: 3px; background-color: white; transition: 0.1s; }
        input:checked + .slider-toggle { background-color: #4aa3df; }
        input:checked + .slider-toggle:before { transform: translateX(14px); }
        
        input[type=range] { width: 90px; cursor: pointer; accent-color: #4aa3df; height: 4px; }

        #btn-fullscreen {
            width: 100%; background: #27ae60; color: white; border: none; padding: 10px; border-radius: 4px;
            font-weight: bold; cursor: pointer; margin-bottom: 10px; font-size: 12px;
        }

        /* Chat */
        #chat-container { 
            pointer-events: auto; position: absolute; top: 10px; left: 10px; 
            width: 250px; height: 150px; display: flex; flex-direction: column; z-index: 50; 
        }
        #chat-history { flex: 1; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 5px; margin-bottom: 5px; font-size: 12px; text-shadow: 1px 1px 1px black; font-family: monospace;}
        #chat-input { background: rgba(255,255,255,0.9); color: black; border: none; width: 100%; box-sizing: border-box; padding: 5px;}
        
        /* --- NEW D-PAD (From SandBox3D) --- */
        .touch-controls { pointer-events: auto; position: absolute; z-index: 40; display: none; }
        
        /* Grid Layout D-Pad */
        .mobile-pad {
            bottom: 20px; left: 20px; width: 140px; height: 140px;
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 5px;
        }
        .d-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px; color: white; font-size: 20px;
            display: flex; justify-content: center; align-items: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .d-btn:active { background: rgba(74, 163, 223, 0.6); border-color: #4aa3df; }
        
        /* Grid Positions */
        .btn-u { grid-column: 2; grid-row: 1; }
        .btn-l { grid-column: 1; grid-row: 2; }
        .btn-r { grid-column: 3; grid-row: 2; }
        .btn-d { grid-column: 2; grid-row: 3; }
        
        /* Action Button */
        #action-zone { right: 20px; bottom: 20px; }
        #btn-jump { 
            width: 80px; height: 80px; border-radius: 50%; 
            background: rgba(255,50,50,0.4); border: 2px solid rgba(255,100,100,0.8); 
            color: white; font-weight: bold; font-size: 14px; 
            display: flex; align-items: center; justify-content: center; user-select: none;
        }
        #btn-jump:active { background: rgba(255,50,50,0.8); }

        hr { border: 0; border-top: 1px solid #444; width: 100%; margin: 8px 0; }
        .section-title { font-size: 10px; color: #888; font-weight: bold; text-transform: uppercase; margin: 5px 0; letter-spacing: 1px; }
    </style>
</head>
<body>

    <canvas id="renderCanvas"></canvas>

    <div id="ui-layer">
        
        <div id="settings-panel" class="ui-panel-base minimized">
            <div class="panel-header">
                <h2>Settings</h2>
                <button class="btn-minimize" id="btn-toggle-ui" onclick="toggleSettingsUI()">⚙️</button>
            </div>
            
            <div class="panel-content">
                <button id="btn-fullscreen" onclick="enterFullscreen()">⛶ FULLSCREEN</button>
                
                <div class="section-title">Visuals</div>
                <div class="setting-row">
                    <span>Shadows</span>
                    <label class="switch"><input type="checkbox" id="opt-shadows" onchange="updateSettings()"><span class="slider-toggle"></span></label>
                </div>
                <div class="setting-row">
                    <span>God Rays</span>
                    <label class="switch"><input type="checkbox" id="opt-godrays" onchange="updateSettings()"><span class="slider-toggle"></span></label>
                </div>
                <div class="setting-row">
                    <span>Bloom</span>
                    <label class="switch"><input type="checkbox" id="opt-bloom" onchange="updateSettings()"><span class="slider-toggle"></span></label>
                </div>
                <div class="setting-row">
                    <span>FXAA</span>
                    <label class="switch"><input type="checkbox" id="opt-fxaa" onchange="updateSettings()"><span class="slider-toggle"></span></label>
                </div>

                <div class="section-title">World</div>
                <div class="setting-row">
                    <span>Time</span>
                    <input type="number" id="opt-time" min="0" max="2400" value="1200" style="width: 50px;" oninput="updateSettings()">
                </div>
                <div class="setting-row">
                    <span>Fog</span>
                    <input type="range" id="opt-fog" min="0" max="100" value="30" oninput="updateSettings()">
                </div>
                
                <div class="section-title">Camera</div>
                <div class="setting-row">
                    <span>FOV</span>
                    <input type="range" id="opt-fov" min="50" max="120" value="80" oninput="updateSettings()">
                </div>
                <div class="setting-row">
                    <span>Distance</span>
                    <input type="range" id="opt-view" min="50" max="500" value="200" oninput="updateSettings()">
                </div>

                <hr>
                <div class="setting-row">
                    <span>Scale: <span id="res-val">100%</span></span>
                    <input type="range" id="opt-res" min="25" max="100" value="100" step="25" oninput="updateSettings()">
                </div>
            </div>
        </div>

        <div id="chat-container">
            <div id="chat-history"></div>
            <input type="text" id="chat-input" placeholder="Type here...">
        </div>

        <div id="connection-panel">
            <h2 style="margin:0 0 10px 0; color:#4aa3df;">CUBLOX v3.5</h2>
            <p style="font-size: 12px; color:#aaa; margin-bottom: 5px;">Player Setup</p>
            <input type="text" id="my-id" placeholder="Username" style="width: 80%;">
            
            <div class="color-row">
                <span style="font-size:12px;">Gradient:</span>
                <input type="color" id="col-start" value="#ff9900">
                <span style="font-size:16px;">➡</span>
                <input type="color" id="col-end" value="#ff0000">
            </div>

            <hr>
            <button class="btn-std" onclick="startHost()">Host Game</button>
            <button class="btn-std" onclick="joinGame()">Join Game</button>
            <br>
            <input type="text" id="host-id" placeholder="Host ID to Join" style="margin-top:10px; width: 80%;">
        </div>

        <div id="dpad" class="touch-controls mobile-pad">
            <div class="d-btn btn-u" id="btn-move-up">▲</div>
            <div class="d-btn btn-l" id="btn-move-left">◀</div>
            <div class="d-btn btn-r" id="btn-move-right">▶</div>
            <div class="d-btn btn-d" id="btn-move-down">▼</div>
        </div>

        <div id="action-zone" class="touch-controls">
            <div id="btn-jump">JUMP</div>
        </div>
    </div>

<script>
/**
 * CUBLOX SB3D - Refined Edition
 * - Controls: Ported from SandBox3D Mobile (Grid D-Pad)
 * - UI: Ported from SandBox3D (Minimizable, Clean)
 * - Network: Fixed Connection Issues (Promise-based init)
 */

// --- 1. ENGINE & SCENE SETUP ---
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
let scene, camera, myPlayerMesh;
let ground, shadowGenerator, pipeline, godRays;
let sunMesh; 

// Game State
let players = {}; 
let inputs = { up: false, down: false, left: false, right: false, jump: false };
let isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
let treeColliders = []; 
let myColor = { top: "#ff9900", bot: "#ff0000" };

// Network
let peer, conn, connections = [], myID = "", isHost = false;

const createScene = () => {
    const s = new BABYLON.Scene(engine);
    s.clearColor = new BABYLON.Color3(0.5, 0.7, 1); 
    s.fogMode = BABYLON.Scene.FOGMODE_EXP2;
    s.fogDensity = 0.003;
    s.fogColor = new BABYLON.Color3(0.5, 0.7, 1);

    // Camera
    camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, 1.2, 20, BABYLON.Vector3.Zero(), s);
    camera.attachControl(canvas, true);
    camera.upperBetaLimit = Math.PI / 2 - 0.05; 
    camera.lowerRadiusLimit = 5;
    camera.upperRadiusLimit = 40;
    camera.checkCollisions = true;
    camera.collisionRadius = new BABYLON.Vector3(0.5, 0.5, 0.5);

    // Lights
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), s);
    light.intensity = 0.6;
    
    const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, -0.5), s);
    dirLight.position = new BABYLON.Vector3(50, 100, 50);
    dirLight.intensity = 1.2;

    // Sun Mesh (For God Rays)
    sunMesh = BABYLON.MeshBuilder.CreateSphere("sunMesh", {diameter: 10}, s);
    sunMesh.position = dirLight.position.scale(5); 
    const sunMat = new BABYLON.StandardMaterial("sunMat", s);
    sunMat.emissiveColor = new BABYLON.Color3(1, 1, 0.8);
    sunMat.disableLighting = true;
    sunMesh.material = sunMat;

    // Shadows
    shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
    shadowGenerator.useBlurExponentialShadowMap = true;
    dirLight.shadowEnabled = false; // Off by default for performance

    // Pipeline
    pipeline = new BABYLON.DefaultRenderingPipeline("pipeline", true, s, [camera]);
    pipeline.samples = 1; 
    pipeline.fxaaEnabled = false;
    pipeline.bloomEnabled = false;
    
    // God Rays
    godRays = new BABYLON.VolumetricLightScatteringPostProcess("godrays", 1.0, camera, sunMesh, 50, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false);
    godRays.exposure = 0.2;
    godRays.decay = 0.96;
    // Detach initially
    s.postProcesses = s.postProcesses.filter(pp => pp !== godRays);

    // Terrain
    const grassMat = new BABYLON.StandardMaterial("grassMat", s);
    grassMat.diffuseColor = new BABYLON.Color3(0.2, 0.5, 0.2);

    ground = BABYLON.MeshBuilder.CreateGroundFromHeightMap("ground", 
        "https://playground.babylonjs.com/textures/heightMap.png", 
        { width: 400, height: 400, subdivisions: 40, minHeight: 0, maxHeight: 40 }, 
        s
    );
    ground.material = grassMat;
    ground.checkCollisions = true;
    ground.receiveShadows = true;

    createCleanBorder(s);

    return s;
};

function createCleanBorder(scene) {
    const logMat = new BABYLON.StandardMaterial("logMat", scene);
    logMat.diffuseColor = new BABYLON.Color3(0.3, 0.2, 0.1);
    const leafMat = new BABYLON.StandardMaterial("leafMat", scene);
    leafMat.diffuseColor = new BABYLON.Color3(0.05, 0.25, 0.05);

    const baseTrunk = BABYLON.MeshBuilder.CreateCylinder("trunk", {height:4, diameter:1}, scene);
    baseTrunk.material = logMat; baseTrunk.isVisible = false; 
    const baseLeaves = BABYLON.MeshBuilder.CreateCylinder("leaves", {diameterTop:0, diameterBottom:4, height:6}, scene);
    baseLeaves.position.y = 4; baseLeaves.material = leafMat; baseLeaves.isVisible = false; 
    
    const masterTree = BABYLON.Mesh.MergeMeshes([baseTrunk, baseLeaves], true, true, undefined, false, true);
    masterTree.name = "masterTree"; masterTree.isVisible = false;

    const range = 195; const step = 10;    
    for (let x = -range; x <= range; x += step) {
        placeTree(masterTree, x, -range); placeTree(masterTree, x, range);  
    }
    for (let z = -range + step; z < range; z += step) {
        placeTree(masterTree, -range, z); placeTree(masterTree, range, z);  
    }
}
function placeTree(master, x, z) {
    const instance = master.createInstance("borderTree");
    instance.position = new BABYLON.Vector3(x, 0, z);
    instance.scaling = new BABYLON.Vector3(0.8 + Math.random()*0.4, 0.8 + Math.random()*0.4, 0.8 + Math.random()*0.4);
    treeColliders.push({ x: x, z: z, radius: 2 });
}

scene = createScene();

// --- 2. SETTINGS & UI ---
function toggleSettingsUI() {
    const panel = document.getElementById('settings-panel');
    const btn = document.getElementById('btn-toggle-ui');
    if (panel.classList.contains('minimized')) {
        panel.classList.remove('minimized'); 
        btn.innerText = "_"; 
    } else {
        panel.classList.add('minimized'); 
        btn.innerText = "⚙️"; 
    }
}

function enterFullscreen() {
    const de = document.documentElement;
    if (de.requestFullscreen) de.requestFullscreen();
    if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape').catch(() => {});
    }
    setTimeout(() => { engine.resize(); }, 200);
}

function updateSettings() {
    // Shadows
    const dirLight = scene.getLightByName("dirLight");
    if(dirLight) dirLight.shadowEnabled = document.getElementById("opt-shadows").checked;

    // Post Processing
    pipeline.bloomEnabled = document.getElementById("opt-bloom").checked;
    pipeline.fxaaEnabled = document.getElementById("opt-fxaa").checked;

    // God Rays
    const raysOn = document.getElementById("opt-godrays").checked;
    const hasRays = scene.postProcesses.includes(godRays);
    if(raysOn && !hasRays) scene.postProcesses.push(godRays);
    else if(!raysOn && hasRays) scene.postProcesses = scene.postProcesses.filter(pp => pp !== godRays);

    // Time
    const rawTime = parseInt(document.getElementById("opt-time").value) || 1200;
    const angle = (rawTime / 2400) * (Math.PI * 2) - (Math.PI / 2);

    if(dirLight) {
        const x = Math.cos(angle);
        const y = -Math.sin(angle); 
        dirLight.direction = new BABYLON.Vector3(x, y, 0.2).normalize();
        sunMesh.position = dirLight.direction.scale(-200); // Move sun visual
        
        let intensity = Math.max(0, y); 
        scene.clearColor = new BABYLON.Color3(0.1 + 0.4*intensity, 0.1 + 0.7*intensity, 0.2 + 0.8*intensity);
        scene.fogColor = scene.clearColor;
        dirLight.intensity = Math.max(0.1, intensity * 1.5);
    }

    // Camera & Fog
    scene.fogDensity = document.getElementById("opt-fog").value / 10000;
    if(camera) {
        camera.fov = (document.getElementById("opt-fov").value * Math.PI) / 180;
        camera.maxZ = parseInt(document.getElementById("opt-view").value);
    }

    // Resolution
    const resVal = parseInt(document.getElementById("opt-res").value);
    document.getElementById("res-val").innerText = resVal + "%";
    engine.setHardwareScalingLevel(100 / resVal);
}

// --- 3. PLAYER SYSTEM ---
function createGradientTexture(name, topColor, botColor) {
    const tex = new BABYLON.DynamicTexture(name, {width: 64, height: 64}, scene);
    const ctx = tex.getContext();
    const grad = ctx.createLinearGradient(0, 0, 0, 64);
    grad.addColorStop(0, topColor);
    grad.addColorStop(1, botColor);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    tex.update();
    return tex;
}

function createPlayerMesh(id, position, colorData) {
    const root = new BABYLON.TransformNode("root_" + id, scene);
    root.position = position || new BABYLON.Vector3(0, 50, 0);

    const body = BABYLON.MeshBuilder.CreateBox("body_" + id, {size: 1.5}, scene);
    body.parent = root;
    const mat = new BABYLON.StandardMaterial("skin_" + id, scene);
    const cData = colorData || { top: "#ff9900", bot: "#ff0000" };
    mat.diffuseTexture = createGradientTexture("grad_" + id, cData.top, cData.bot);
    body.material = mat;
    if (shadowGenerator) shadowGenerator.addShadowCaster(body);

    // Face
    const facePlane = BABYLON.MeshBuilder.CreatePlane("face_" + id, {size: 1}, scene);
    facePlane.parent = body; facePlane.position.z = 0.76;
    const faceTex = new BABYLON.DynamicTexture("faceTex_" + id, {width:256, height:256}, scene);
    const faceMat = new BABYLON.StandardMaterial("faceMat_" + id, scene);
    faceMat.diffuseTexture = faceTex; faceMat.emissiveColor = new BABYLON.Color3(1,1,1); faceTex.hasAlpha = true;
    facePlane.material = faceMat;

    const drawFace = (expr) => {
        const ctx = faceTex.getContext();
        ctx.clearRect(0,0,256,256); ctx.fillStyle = "black";
        if (expr === "happy") {
            ctx.fillRect(60, 80, 40, 40); ctx.fillRect(156, 80, 40, 40);
            ctx.beginPath(); ctx.arc(128, 160, 60, 0, Math.PI, false); ctx.lineWidth = 15; ctx.stroke();
        } else if (expr === "jump") {
            ctx.fillRect(60, 60, 40, 40); ctx.fillRect(156, 60, 40, 40);
            ctx.beginPath(); ctx.arc(128, 170, 30, 0, Math.PI * 2, false); ctx.fill();
        }
        faceTex.update();
    };
    drawFace("happy");

    // Nametag
    const namePlane = BABYLON.MeshBuilder.CreatePlane("name_" + id, {width: 4, height: 1}, scene);
    namePlane.parent = root; namePlane.position.y = 1.3;
    namePlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    const nameTex = new BABYLON.DynamicTexture("nameTex_" + id, {width: 512, height: 128}, scene);
    const nameMat = new BABYLON.StandardMaterial("nameMat_" + id, scene);
    nameMat.diffuseTexture = nameTex; nameMat.emissiveColor = new BABYLON.Color3(1,1,1); nameTex.hasAlpha = true;
    namePlane.material = nameMat;
    nameTex.getContext().font = "bold 60px monospace";
    nameTex.getContext().fillStyle = "white";
    nameTex.getContext().textAlign = "center";
    nameTex.getContext().fillText(id, 256, 80);
    nameTex.update();

    root.bodyMesh = body;
    root.drawFace = drawFace;
    root.animState = { walkTime: 0, isGrounded: false, vy: 0 };
    
    // Chat Bubble
    const bubblePlane = BABYLON.MeshBuilder.CreatePlane("bubble_" + id, {width: 6, height: 2}, scene);
    bubblePlane.parent = root; bubblePlane.position.y = 2.5;
    bubblePlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL; bubblePlane.isVisible = false;
    const bubbleTex = new BABYLON.DynamicTexture("bubbleTex_" + id, {width: 512, height: 256}, scene);
    const bubbleMat = new BABYLON.StandardMaterial("bubbleMat_" + id, scene);
    bubbleMat.diffuseTexture = bubbleTex; bubbleMat.emissiveColor = new BABYLON.Color3(1,1,1); bubbleTex.hasAlpha = true;
    bubblePlane.material = bubbleMat;
    root.showChat = (text) => {
        bubblePlane.isVisible = true;
        const ctx = bubbleTex.getContext();
        ctx.clearRect(0,0,512,256);
        ctx.fillStyle = "rgba(255,255,255,0.9)"; ctx.fillRect(10,10,492,236);
        ctx.font = "40px monospace"; ctx.fillStyle = "black"; ctx.textAlign = "center";
        ctx.fillText(text.substring(0, 20), 256, 130);
        bubbleTex.update();
        setTimeout(() => { bubblePlane.isVisible = false; }, 4000);
    };

    return root;
}

// Controls
window.addEventListener("keydown", (e) => {
    if(document.activeElement === document.getElementById("chat-input")) return;
    if(e.key === "w" || e.key === "ArrowUp") inputs.up = true;
    if(e.key === "s" || e.key === "ArrowDown") inputs.down = true;
    if(e.key === "a" || e.key === "ArrowLeft") inputs.left = true;
    if(e.key === "d" || e.key === "ArrowRight") inputs.right = true;
    if(e.code === "Space") inputs.jump = true;
});
window.addEventListener("keyup", (e) => {
    if(e.key === "w" || e.key === "ArrowUp") inputs.up = false;
    if(e.key === "s" || e.key === "ArrowDown") inputs.down = false;
    if(e.key === "a" || e.key === "ArrowLeft") inputs.left = false;
    if(e.key === "d" || e.key === "ArrowRight") inputs.right = false;
    if(e.code === "Space") inputs.jump = false;
});

// Mobile Controls (SB3D Logic)
if (isMobile) {
    document.querySelectorAll(".touch-controls").forEach(el => el.style.display = "grid");
    // Explicitly show jump as block since it's not a grid pad
    document.getElementById("action-zone").style.display = "block";
    
    const bindTouch = (id, key) => {
        const btn = document.getElementById(id);
        if(!btn) return;
        btn.addEventListener("touchstart", (e) => { e.preventDefault(); inputs[key] = true; });
        btn.addEventListener("touchend", (e) => { e.preventDefault(); inputs[key] = false; });
    };
    // Map SB3D Grid IDs to Input Logic
    bindTouch("btn-move-up", "up"); bindTouch("btn-move-down", "down");
    bindTouch("btn-move-left", "left"); bindTouch("btn-move-right", "right");
    bindTouch("btn-jump", "jump");
}

let velocity = new BABYLON.Vector3(0, 0, 0);
const SPEED = 0.4;
const GRAVITY = -0.025;
const JUMP_FORCE = 0.5;

// Main Loop
scene.registerBeforeRender(() => {
    if (!myPlayerMesh || !ground.isReady()) return;

    // Movement
    camera.target = myPlayerMesh.position.add(new BABYLON.Vector3(0, 1.5, 0));

    let moveDir = BABYLON.Vector3.Zero();
    let forward = camera.getDirection(BABYLON.Axis.Z);
    forward.y = 0; forward.normalize();
    let right = camera.getDirection(BABYLON.Axis.X);
    right.y = 0; right.normalize();

    if (inputs.up) moveDir.addInPlace(forward);
    if (inputs.down) moveDir.subtractInPlace(forward);
    if (inputs.right) moveDir.addInPlace(right);
    if (inputs.left) moveDir.subtractInPlace(right);

    const isMoving = moveDir.length() > 0;

    if (isMoving) {
        moveDir.normalize();
        velocity.x = moveDir.x * SPEED;
        velocity.z = moveDir.z * SPEED;
        myPlayerMesh.lookAt(myPlayerMesh.position.add(moveDir));
    } else {
        velocity.x = 0; velocity.z = 0; 
    }

    let groundHeight = ground.getHeightAtCoordinates(myPlayerMesh.position.x, myPlayerMesh.position.z);
    let isGrounded = (myPlayerMesh.position.y - 0.75 <= groundHeight + 0.5);

    if (isGrounded) {
        if (velocity.y <= 0) {
            myPlayerMesh.position.y = groundHeight + 0.75; 
            velocity.y = 0;
            if(!inputs.jump) myPlayerMesh.drawFace("happy");
        }
        if (inputs.jump) {
            velocity.y = JUMP_FORCE;
            myPlayerMesh.drawFace("jump");
            myPlayerMesh.position.y += 0.2;
            isGrounded = false;
        }
    } else {
        velocity.y += GRAVITY;
    }

    let nextX = myPlayerMesh.position.x + velocity.x;
    let nextZ = myPlayerMesh.position.z + velocity.z;
    let hitTree = false;
    for (let t of treeColliders) {
        let dx = nextX - t.x; let dz = nextZ - t.z;
        if (dx*dx + dz*dz < 4) { hitTree = true; break; }
    }
    if (!hitTree) {
        myPlayerMesh.position.x = nextX;
        myPlayerMesh.position.z = nextZ;
    }
    myPlayerMesh.position.y += velocity.y;
    if (myPlayerMesh.position.y < -10) { myPlayerMesh.position.y = 50; velocity = BABYLON.Vector3.Zero(); }

    const body = myPlayerMesh.bodyMesh;
    if (isGrounded && isMoving) {
        myPlayerMesh.animState.walkTime += 0.3;
        body.rotation.z = Math.sin(myPlayerMesh.animState.walkTime) * 0.1;
        body.position.y = Math.abs(Math.sin(myPlayerMesh.animState.walkTime)) * 0.2;
    } else if (isGrounded && !isMoving) {
        body.rotation.z *= 0.8; body.position.y *= 0.8; 
    }
    if (!isGrounded) body.rotation.x += 0.15;
    else if (Math.abs(body.rotation.x) > 0.1) body.rotation.x = 0;

    if (peer && peer.open) {
        broadcastData({
            type: "move", id: myID, 
            pos: myPlayerMesh.position,
            rot: myPlayerMesh.rotation,
            anim: { moving: isMoving, grounded: isGrounded }
        });
    }
});

// --- 4. NETWORK (Promise-Based Fix) ---

function createPeer(id) {
    return new Promise((resolve, reject) => {
        const p = new Peer(id);
        p.on('open', (assignedId) => {
            resolve(p);
        });
        p.on('error', (err) => {
            console.error("Peer Error:", err);
            reject(err);
        });
    });
}

function setupGameSession(id) {
    myID = id;
    myColor.top = document.getElementById("col-start").value;
    myColor.bot = document.getElementById("col-end").value;
    document.getElementById("connection-panel").style.display = "none";
    addSystemMessage("Welcome, " + id);
    myPlayerMesh = createPlayerMesh(id, null, myColor);
}

function startHost() {
    let id = document.getElementById("my-id").value || "Host" + Math.floor(Math.random()*100);
    addSystemMessage("Initializing Host...");
    
    // Wait for Peer Open
    createPeer(id).then((p) => {
        peer = p;
        isHost = true;
        setupGameSession(id);
        addSystemMessage("Server Started. ID: " + id);
        
        peer.on('connection', (c) => {
            connections.push(c); 
            setupConnectionEvent(c); 
            addSystemMessage("A player connected.");
        });
    }).catch(err => {
        alert("ID taken or connection failed.");
    });
}

function joinGame() {
    isHost = false;
    let myName = document.getElementById("my-id").value || "Guest" + Math.floor(Math.random()*100);
    let hostID = document.getElementById("host-id").value;

    if(!hostID) return alert("Enter Host ID");

    addSystemMessage("Initializing Client...");

    // 1. Create Self
    createPeer(myName).then((p) => {
        peer = p;
        setupGameSession(myName);
        addSystemMessage("Connecting to " + hostID + "...");

        // 2. Connect to Host
        conn = peer.connect(hostID);
        
        conn.on('open', () => { 
            setupConnectionEvent(conn); 
            addSystemMessage("Joined Successfully!");
            conn.send({ type: "join", id: myName, color: myColor }); 
        });

        conn.on('error', (err) => {
            alert("Could not connect to host.");
        });

    }).catch(err => {
        alert("Username taken.");
    });
}

function setupConnectionEvent(c) { c.on('data', (data) => handleData(data, c)); }

function handleData(data, senderConn) {
    if (data.type === "join") {
        addSystemMessage(data.id + " joined.");
        if (isHost) {
            if(!players[data.id]) {
                players[data.id] = createPlayerMesh(data.id, new BABYLON.Vector3(0,50,0), data.color);
            }
            relayData(data, senderConn);
            senderConn.send({ type: "join", id: myID, color: myColor });
            // Sync existing players
            for(let pid in players) {
                 if(pid !== data.id) senderConn.send({type: "join", id: pid, color: {top:"#aaa", bot:"#555"}}); // Simple sync
            }
        }
        else {
            if(!players[data.id] && data.id !== myID) {
                players[data.id] = createPlayerMesh(data.id, new BABYLON.Vector3(0,50,0), data.color);
            }
        }
    }

    if (data.type === "move") {
        if (data.id === myID) return;
        let p = players[data.id];
        if (!p) {
            players[data.id] = createPlayerMesh(data.id, new BABYLON.Vector3(data.pos.x, data.pos.y, data.pos.z));
            p = players[data.id];
        }
        p.position = new BABYLON.Vector3(data.pos.x, data.pos.y, data.pos.z);
        if (data.rot) p.rotation = new BABYLON.Vector3(data.rot.x, data.rot.y, data.rot.z);
        
        const body = p.bodyMesh;
        if(data.anim) {
             if (data.anim.grounded && data.anim.moving) {
                p.animState.walkTime += 0.3;
                body.rotation.z = Math.sin(p.animState.walkTime) * 0.1;
                body.position.y = Math.abs(Math.sin(p.animState.walkTime)) * 0.2;
            } else if (data.anim.grounded) {
                 body.rotation.z *= 0.8; body.position.y *= 0.8;
            } else {
                 body.rotation.x += 0.15;
            }
        }
        if (isHost) relayData(data, senderConn);
    }
    
    if (data.type === "chat") {
        addChatMessage(data.id, data.msg);
        if (players[data.id]) players[data.id].showChat(data.msg);
        if (isHost) relayData(data, senderConn);
    }
}

function relayData(data, excludeConn) { connections.forEach(c => { if (c !== excludeConn && c.open) c.send(data); }); }
function broadcastData(data) {
    if (isHost) connections.forEach(c => { if(c.open) c.send(data); });
    else if (conn && conn.open) conn.send(data);
}

// Chat
const chatInput = document.getElementById("chat-input");
const chatHistory = document.getElementById("chat-history");
chatInput.addEventListener("keypress", (e) => {
    if (e.key === "Enter" && chatInput.value !== "") {
        let msg = chatInput.value;
        addChatMessage(myID, msg);
        if(myPlayerMesh) myPlayerMesh.showChat(msg);
        broadcastData({ type: "chat", id: myID, msg: msg });
        chatInput.value = "";
    }
});
function addChatMessage(id, msg) {
    const div = document.createElement("div"); div.innerText = `${id}: ${msg}`;
    chatHistory.appendChild(div); chatHistory.scrollTop = chatHistory.scrollHeight;
}
function addSystemMessage(msg) {
    const div = document.createElement("div"); div.innerText = `> ${msg}`; div.style.color = "#4aa3df";
    chatHistory.appendChild(div);
}

// Start
updateSettings();
engine.runRenderLoop(() => { scene.render(); });
window.addEventListener("resize", () => { engine.resize(); });
</script>
</body>
</html>